<!DOCTYPE html>
<html  lang="en" >
<head>
	<meta charset="UTF-8"/>
		<meta name="author" content="Erencan Ceyhan"/>
			<meta name="keywords" content="C++, Programlama, Teknoloji, Gönderi, Ödev, Işın İzleme"/>
		<title>CENG795-HW5: High Dynamic Raytracing</title>
	<link href="/style/index.css" rel="stylesheet"/>
</head>
<body>

<div id="header">
	<a id="site-header" href="/"><h1>Erencan'ın Köşesi</h1></a>

	<div id="page-header">
		<h1>CENG795-HW5: High Dynamic Raytracing</h1>
	</div>
</div>

<div id="content">

	<article class="card">
		<ul>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#material-refactor">Material Refactor</a></li>
<li><a href="#directional-lights">Directional Lights</a></li>
<li><a href="#spot-light">Spot Light</a></li>
<li><a href="#tonemapping">Tonemapping</a></li>
<li><a href="#hdr-environment-map">HDR Environment Map</a></li>
</ul></li>
<li><a href="#results">Results</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<p>Hello again minasan! Welcome again to yet another CENG795 homework post. Unfortunately, this post will not be that nice compared to the previous ones. HW3, HW4 and HW5 have been all pretty easy to do. In this one however, unlike the others, I have not done any “adventurous” thing in this one unfortunately; nevertheless, I will try to do my best to make this post interesting.</p>
<h1 id="implementation">Implementation</h1>
<h2 id="material-refactor">Material Refactor</h2>
<p>I have started doing some refactoring since the previous homework, as I had written in the blog post of the previous homework. In this homework, I have pretty much completed the refactoring by migrating material system from <code>std::variant</code> to virtual methods. In the <a href="#performance">performance</a> section, you can see a comparison between the two implementations, a benchmark I did before implementing HDR support.</p>
<p>The new architecture is pretty similar to the texture architecture I had implemented in the previous homework. There is an interface (or an abstract class, since C++ does not have interfaces) named <code>IMaterial</code>. It is defined as this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> IMaterial <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> glm<span class="op">::</span>vec3 shadeMaterial<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 shade<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The main work is done by <code>shadeMaterial</code>, which is overriden by the child classes. The <code>shade</code> method (or <em>mixin</em>) just does recursion depth check and calls <code>shadeMaterial</code> if it is not exceeded. I made it a separate method since otherwise, this check would be the first line in every override of <code>shadeMaterial</code>.</p>
<p>The data is defined in semi-POD <code>struct</code>s (semi since non-default constructors break this). The <code>struct</code> of simple materials is as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> DSimple <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 ambient_reflectance <span class="op">=</span> <span class="op">{};</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 diffuse_reflectance <span class="op">=</span> <span class="op">{};</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 specular_reflectance <span class="op">=</span> <span class="op">{};</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> roughness <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> phong_exponent <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    DSimple<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    DSimple<span class="op">(</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        glm<span class="op">::</span>vec3 ambient_reflectance<span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        glm<span class="op">::</span>vec3 diffuse_reflectance<span class="op">,</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        glm<span class="op">::</span>vec3 specular_reflectance<span class="op">,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> roughness<span class="op">,</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> phong_exponent</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 simpleShade<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 reflectShade<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The data is just what each material has, there is a constructor taking each of these so that I can construct an instance directly. I also re-defined default constructor since defining another constructor removes the default one. I also created some helper methods for shading. The other materials are pretty much the same except there is no helper methods and they inherit from <code>DSimple</code>. The real <code>struct</code>s are defined similar to <code>Simple</code>, which is defined as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Simple <span class="op">:</span> DSimple<span class="op">,</span> IMaterial <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    Simple<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    Simple<span class="op">(</span><span class="at">const</span> DSimple<span class="op">&amp;</span> simple<span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3 shadeMaterial<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>It takes the data as itself and copies it. The <code>IMaterial</code> is there to provide the <code>shade</code> and polymorphism.</p>
<p>The scene now holds <code>std::unique_ptr</code>s if <code>IMaterial</code>s, which actually decreases cache efficiency since now the materials are not actually contiguous; however, this should not decrease the performance that much, since materials are not used consecutively anyways, they are used based on which object a ray hits. There is usually not much of a spatial locality in material access, but there is temporal locality (since neighboring rays have more chance to hit an object of same material), and storing pointers does not decrease it more than using sum types. This actually did not change the number of lines that much, but now the code is much cleaner and modularized, which is a huge bonus.</p>
<h2 id="directional-lights">Directional Lights</h2>
<p>The next thing I did was doing directional lights. However, in my generic <code>diffuse</code> and <code>specular</code> functions, which calculate the diffuse and specular shading results, respectively, I took the position of the light, which is the real position of the point light and the sampled point for area lights. The shadow ray is also calculated using the position of the light. However, directional lights <em>do not</em> have positions! What I did was pretty much a hack. Shadow casts check for whether the intersection distance (which equals <code>t</code> since direction is a unit vector) is smaller than the distance between the light and the origin of the ray. If there is no hit, the point is not in shadow. If there is a hit but the hit is farther than the light, there is still no shadow. The code was this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">bool</span> castShadowRay<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">,</span> glm<span class="op">::</span>vec3 target<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> hi <span class="op">=</span> HitInfo<span class="op">();</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> origin <span class="op">=</span> args<span class="op">.</span>hit_point <span class="op">+</span> args<span class="op">.</span>n <span class="op">*</span> args<span class="op">.</span>s<span class="op">.</span>shadow_ray_epsilon<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> sent_ray <span class="op">=</span> Ray<span class="op">{.</span>origin <span class="op">=</span> origin<span class="op">,</span> <span class="op">.</span>direction <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>target <span class="op">-</span> origin<span class="op">),</span> <span class="op">.</span>time <span class="op">=</span> args<span class="op">.</span>ray_time<span class="op">};</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span><span class="kw">not</span> args<span class="op">.</span>s<span class="op">.</span>rayCast<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;(</span>sent_ray<span class="op">,</span> hi<span class="op">)</span> <span class="kw">or</span> hi<span class="op">.</span>t <span class="op">&gt;</span> glm<span class="op">::</span>length<span class="op">(</span>target <span class="op">-</span> origin<span class="op">));</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It creates a <code>HitInfo</code> <code>struct</code>, the ray and casts it in the scene without backface culling (denoted by <code>&lt;false&gt;</code>). The logic is the same as I said in the previous paragraph. Solving this was actually a bit harder than solving the shading. In the shading, I created a new point, which is in the opposite direction of the direction of the light from the hit point. This is something like the origin point of the light, but the distance between the hit point and light position is always parallel to the light’s direction, which is the whole point (pun not intended) of the directional light.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> virtual_light_position <span class="op">=</span> args<span class="op">.</span>hit_point <span class="op">-</span> light<span class="op">.</span>direction<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="kw">not</span> castShadowRay<span class="op">(</span>args<span class="op">,</span> virtual_light_position<span class="op">))</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> diffuse_value <span class="op">=</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    diffuse<span class="op">(</span>virtual_light_position<span class="op">,</span> light<span class="op">.</span>radiance<span class="op">,</span> diffuse_reflectance<span class="op">,</span> args<span class="op">.</span>n<span class="op">,</span> args<span class="op">.</span>hit_point<span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> specular_value <span class="op">=</span> specular<span class="op">(</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    virtual_light_position<span class="op">,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    light<span class="op">.</span>radiance<span class="op">,</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    specular_reflectance<span class="op">,</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    args<span class="op">.</span>n<span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    args<span class="op">.</span>hit_point<span class="op">,</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    args<span class="op">.</span>camera_pos<span class="op">,</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    phong_exponent</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>ret <span class="op">+=</span> diffuse_value <span class="op">+</span> specular_value<span class="op">;</span></span></code></pre></div>
<p>The <code>virtual_light_position</code> is the point I have talked about in the previous paragraph. This piece of code is inside a <code>for</code> loop over directional lights, so the <code>continue</code> just means a skip of this light due to shadow.</p>
<p>However, the result is this:</p>
<figure>
<img src="./assets/cube_directional_distance_check.png" alt="Cube under Cropped Directional Light" />
<figcaption aria-hidden="true">Cube under Cropped Directional Light</figcaption>
</figure>
<p>As you can see, the shadow is cut at the right of the image. After some debugging, I found out that this was due to the fact that the <code>castShadowRay</code> function thinks that there is no shadow at those places since the ray hit (which is on the cube) is not in front of the light, which is at position <code>virtual_light_position</code>, so the distance is <code>1</code>. Solving this was a bit harder than solving the shading, but still pretty easy. After changing the <code>castShadowRay</code> to this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="dt">bool</span> castShadowRay<span class="op">(</span><span class="at">const</span> shading_arguments<span class="op">&amp;</span> args<span class="op">,</span> glm<span class="op">::</span>vec3 target<span class="op">,</span> <span class="dt">bool</span> check_distance <span class="op">=</span> <span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> hi <span class="op">=</span> HitInfo<span class="op">();</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> origin <span class="op">=</span> args<span class="op">.</span>hit_point <span class="op">+</span> args<span class="op">.</span>n <span class="op">*</span> args<span class="op">.</span>s<span class="op">.</span>shadow_ray_epsilon<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> sent_ray <span class="op">=</span> Ray<span class="op">{.</span>origin <span class="op">=</span> origin<span class="op">,</span> <span class="op">.</span>direction <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>target <span class="op">-</span> origin<span class="op">),</span> <span class="op">.</span>time <span class="op">=</span> args<span class="op">.</span>ray_time<span class="op">};</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span><span class="kw">not</span> args<span class="op">.</span>s<span class="op">.</span>rayCast<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;(</span>sent_ray<span class="op">,</span> hi<span class="op">)</span> <span class="kw">or</span> <span class="op">(</span>check_distance <span class="kw">and</span> hi<span class="op">.</span>t <span class="op">&gt;</span> glm<span class="op">::</span>length<span class="op">(</span>target <span class="op">-</span> origin<span class="op">)));</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and calling it with <code>false</code> as the third argument <em>only in directional lights</em> solves this issue.</p>
<figure>
<img src="./assets/cube_directional.png" alt="Cube under Directional Light" />
<figcaption aria-hidden="true">Cube under Directional Light</figcaption>
</figure>
<p>Yep, the directional light was this!</p>
<h2 id="spot-light">Spot Light</h2>
<p>Spot lights are a bit harder than directional lights since they need a bit of maths. Since the angle between two vectors can easily be computed using dot products if both of vectors are normalized, which can be the case since the direction of the spotlight can be normalized in parsing, which I did. However, the result was this:</p>
<figure>
<img src="./assets/cube_point_wrong.png" alt="Wrong Cube under Spot Light" />
<figcaption aria-hidden="true">Wrong Cube under Spot Light</figcaption>
</figure>
<figure>
<img src="./assets/dragon_spot_light_msaa_light_falloff_instead_of_coverage_cos_half.png" alt="Wrong Dragon under Spot Light" />
<figcaption aria-hidden="true">Wrong Dragon under Spot Light</figcaption>
</figure>
<p>There was definitely a calculation error here. After some painful debugging sessions, I found out the culprit:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>cos_a <span class="op">-</span> light<span class="op">.</span>falloff_cos_half<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>light<span class="op">.</span>falloff_cos_half <span class="op">-</span> light<span class="op">.</span>coverage_cos_half<span class="op">)</span></span></code></pre></div>
<p>or in math notation</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>α</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">falloff</mtext><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">falloff</mtext><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">coverage</mtext><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">
\frac{\cos(\alpha) - \cos(\text{falloff} / 2)}{\cos(\text{falloff}/2) - \cos(\text{coverage}/2)}
</annotation></semantics></math></p>
<p>This is what is written in the homework PDF and it has a small error: the substraction in the nominator should be between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>α</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\cos(\alpha)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">coverage</mtext><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\cos(\text{coverage}/2)</annotation></semantics></math>, not <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>cos</mi><mo>&#8289;</mo></mrow><mo stretchy="false" form="prefix">(</mo><mtext mathvariant="normal">falloff</mtext><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\cos(\text{falloff}/2)</annotation></semantics></math>. After fixing that error, I got the correct result:</p>
<figure>
<img src="./assets/dragon_spot_light_msaa.png" alt="Dragon under Spot Light" />
<figcaption aria-hidden="true">Dragon under Spot Light</figcaption>
</figure>
<p>Unfortunately, I don’t have the ground truth for cube under spotlight since it is a case I created to test spotlight. It shows the errors, but I cannot know whether it is rendered correctly. However, I do not think there should be an issue since dragon is rendered correctly, almost pixel perfect.</p>
<h2 id="tonemapping">Tonemapping</h2>
<p>Abstractions, abstractions, abstractions. So far, the tonemapping (which was simple clamping) had been done in the last step right before writing the color to the image. However, tonemapping needs the HDR values, not 8-bit values, which the image was. Hence, I did an abstraction and created an interface, <code>ITonemapper</code>. The <code>DClamp</code> (and <code>Clamp</code>) and <code>DReinhard</code> (and <code>Reinhard</code>) are defined similar to my previous classes. <code>Clamp</code> implements the usual clamping while <code>Reinhard</code> implements the Photographic TMO. <code>Clamp</code> currently takes saturation and gamma; however, it does not use this since <code>Clamp</code> simulates previous homeworks, which did not have gamma and saturation. <code>Reinhard</code> on the other hand handles both of them.</p>
<p>Implementing the TMO was also pretty easy, I pretty much implemented the algorithm from the slides and the global operator is pretty easy. However, the result was a bit off.</p>
<figure>
<img src="./assets/sphere_point_hdr_texture_delta.png" alt="Too Bright Sphere with HDR Texture and Artifacts" />
<figcaption aria-hidden="true">Too Bright Sphere with HDR Texture and Artifacts</figcaption>
</figure>
<p>The image was somewhat brighter than the instructor’s output. Furthermore, the lights had weird artifacts, their brightest parts were colored instead of being white. After long (longest in this homework) and painful debugging and toilet sessions, the God revealed me the reason, which was clamping the luminance. Such a simple mistake, and the output was wrong in such an obvious way!</p>
<p>While tonemapping each pixel, I had this code in the <code>for</code> loop:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> luminance <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>image<span class="op">[</span>i<span class="op">],</span> luminancer<span class="op">);</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> L <span class="op">=</span> zone_factor <span class="op">*</span> luminance<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> L_d <span class="op">=</span> glm<span class="op">::</span>clamp<span class="op">(</span><span class="dt">float</span><span class="op">(</span>L <span class="op">/</span> <span class="op">(</span><span class="fl">1.0</span> <span class="op">+</span> L<span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">+</span> L <span class="op">/</span> L_w_2<span class="op">)),</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> value <span class="op">=</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>clamp<span class="op">(</span>L_d <span class="op">*</span> glm<span class="op">::</span>pow<span class="op">(</span>image<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> luminance<span class="op">,</span> glm<span class="op">::</span>vec3<span class="op">(</span>saturation<span class="op">)),</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">),</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> gamma_corrected <span class="op">=</span> glm<span class="op">::</span>pow<span class="op">(</span>value<span class="op">,</span> glm<span class="op">::</span>vec3<span class="op">(</span>degamma<span class="op">));</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>ret<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> glm<span class="op">::</span>u8vec3<span class="op">(</span><span class="fl">255.0</span><span class="bu">f</span> <span class="op">*</span> glm<span class="op">::</span>clamp<span class="op">(</span>gamma_corrected<span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span></code></pre></div>
<p>The <code>luminancer</code> is defined as this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> luminancer <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">0.2126</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.7152</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0722</span><span class="bu">f</span><span class="op">);</span></span></code></pre></div>
<p>which is the weights of each channel in luminance calculation. <code>zone_factor</code> is the <code>key</code>, one of the parameters of the TMO, divided by the geometric average of the luminances. This result would then be multiplied to get the <code>L</code> in the formula, which is then mapped using the global TMO with burn-out. However, as one can see, the resulting <code>L_d</code> is clamped to <code>[0,1]</code> range. I did not see this as an error, but when I removed it, those artifacts were gone!</p>
<figure>
<img src="./assets/sphere_point_hdr_texture_only_delta.png" alt="Too Bright Sphere with HDR Texture" />
<figcaption aria-hidden="true">Too Bright Sphere with HDR Texture</figcaption>
</figure>
<p>However, the image was still brighter than the ground truth. After a bit of experimenting, I found out that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> in the geometric average changed the result considerably, brightening or darkening the whole image. I guess the reason is that the image has too many black pixels (with luminance <code>0</code>), which means that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> was significant, since it affected the result. After binary searching, I found out that my <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.5</mn><mo>×</mo><msup><mn>10</mn><mrow><mi>−</mi><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2.5\times 10^{-4}</annotation></semantics></math> more-or-less corresponds to the ground truth. The result was almost pixel perfect copy of the ground truth image:</p>
<figure>
<img src="./assets/sphere_point_hdr_texture_correct.png" alt="Correct Sphere with HDR Texture" />
<figcaption aria-hidden="true">Correct Sphere with HDR Texture</figcaption>
</figure>
<p>I also used tinyEXR to handle EXR files, since the HDR textures were given as EXR files and stb does not support EXR files, only HDR files. Currently, the scene is always exported as both PNG (tonemapped with clamping, or Reinhard if it is defined) and HDR (not EXR). This means that one of the other small but significant parts of the homework. My current raytracer however <em>always</em> exports HDR, not when the output is EXR or HDR, it also does not export EXR. This is pretty easy to implement but network homework, term project and New Year decreased my time budget for this homework.</p>
<h2 id="hdr-environment-map">HDR Environment Map</h2>
<p>And here comes the last part of the homework! Even though improving the outputs’ visuals massively, implementing the environment maps was also straightforward like the previous parts of the homework. Until now, there have been no code in the <code>lights.cpp</code>, since lights had been handled in the shading function, which is probably a bit bad in terms of architecturing the program but it have worked. However, since sampling an environment map is also done to sample the background, I decided to make it its own function. It is defined as the follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 rt<span class="op">::</span>EnvironmentLight<span class="op">::</span>sample<span class="op">(</span>glm<span class="op">::</span>vec3 direction<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> d <span class="op">=</span> direction<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> uv <span class="op">=</span> glm<span class="op">::</span>vec2<span class="op">();</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>sampling<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> rt<span class="op">::</span>EnvironmentLight<span class="op">::</span>Sampling<span class="op">::</span>LatLong<span class="op">:</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            uv<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">+</span> <span class="bu">std::</span>atan2<span class="op">(</span>d<span class="op">.</span>x<span class="op">,</span> <span class="op">-</span>d<span class="op">.</span>z<span class="op">)</span> <span class="op">/</span> <span class="bu">std::</span>numbers::pi<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            uv<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>acos<span class="op">(</span>d<span class="op">.</span>y<span class="op">)</span> <span class="op">/</span> <span class="bu">std::</span>numbers::pi<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> rt<span class="op">::</span>EnvironmentLight<span class="op">::</span>Sampling<span class="op">::</span>Probe<span class="op">:</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> <span class="kw">auto</span> r <span class="op">=</span> <span class="bu">std::</span>acos<span class="op">(-</span>d<span class="op">.</span>z<span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="bu">std::</span>numbers::pi <span class="op">*</span> <span class="bu">std::</span>sqrt<span class="op">(</span>d<span class="op">.</span>x <span class="op">*</span> d<span class="op">.</span>x <span class="op">+</span> d<span class="op">.</span>y <span class="op">*</span> d<span class="op">.</span>y<span class="op">));</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            uv<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">(</span>r <span class="op">*</span> d<span class="op">.</span>x <span class="op">+</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            uv<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">(-</span>r <span class="op">*</span> d<span class="op">.</span>y <span class="op">+</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">*=</span> glm<span class="op">::</span>vec2<span class="op">(</span>image<span class="op">.</span>width<span class="op">,</span> image<span class="op">.</span>height<span class="op">);</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> image<span class="op">.</span>sample<span class="op">(</span>uv<span class="op">.</span>x<span class="op">,</span> uv<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It takes a direction vector and converts it to UV coordinates using the proper formula and samples the texture. Again, this was a piece of code that worked at the first time, giving me the rare programmer satisfaction yet again.</p>
<p>However, I did not use rejection sampling at first, since the non-uniform radial sampling was much easier to implement, while giving similar results. I created a <code>getRandomDirection</code> function in order to modularize it so that I could change it later, which would be really handy. The code was this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> glm<span class="op">::</span>vec3 getRandomDirection<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> theta <span class="op">=</span> getRandomNumber<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">2.0</span><span class="bu">f</span> <span class="op">*</span> <span class="bu">std::</span>numbers::pi<span class="op">);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> phi <span class="op">=</span> getRandomNumber<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="bu">std::</span>numbers::pi<span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="bu">std::</span>sin<span class="op">(</span>phi<span class="op">)</span> <span class="op">*</span> <span class="bu">std::</span>cos<span class="op">(</span>theta<span class="op">),</span> <span class="bu">std::</span>sin<span class="op">(</span>phi<span class="op">)</span> <span class="op">*</span> <span class="bu">std::</span>sin<span class="op">(</span>theta<span class="op">),</span> <span class="bu">std::</span>cos<span class="op">(</span>phi<span class="op">));</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>where <code>getRandomNumber</code> gives a random uniform number in the given range. I changed this function to a proper rejection sampling one <em>after</em> finishing the other parts of the homework. The final <code>getRandomDirection</code> is this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> glm<span class="op">::</span>vec3 getRandomDirection<span class="op">()</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dir <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span>getRandomNumber<span class="op">(-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">),</span> getRandomNumber<span class="op">(-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">),</span> getRandomNumber<span class="op">(-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>glm<span class="op">::</span>dot<span class="op">(</span>dir<span class="op">,</span> dir<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        dir <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span>getRandomNumber<span class="op">(-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">),</span> getRandomNumber<span class="op">(-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">),</span> getRandomNumber<span class="op">(-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dir<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I also measured the performance of both. The result was that random rejection sampling is noticeably slower but not that much. The results are in the <a href="#performance">performance</a> section.</p>
<p>At first, I forgot to use the sampled value as a light source and instead directly set the final value, which resulted in this:</p>
<figure>
<img src="./assets/sphere_env_light_no_shading.png" alt="Sphere under Environment Light without Shading" />
<figcaption aria-hidden="true">Sphere under Environment Light without Shading</figcaption>
</figure>
<p>I immediately realized this mistake and fixed it easily by considering the result as a directional light coming from the sampled direction. However, there was still a problem since the output looked like a black hole:</p>
<figure>
<img src="./assets/sphere_env_light_black_hole.png" alt="Black Hole under Environment Light" />
<figcaption aria-hidden="true">Black Hole under Environment Light</figcaption>
</figure>
<figure>
<img src="./assets/black_hole.png" alt="Another Black Hole under Environment Light (This Time Starry Space)" />
<figcaption aria-hidden="true">Another Black Hole under Environment Light (This Time Starry Space)</figcaption>
</figure>
<p>After looking at the black hole and seeing my future in its singularity, I found out that I took the direction of the light ray in the opposite direction. In the directional light, the direction is the light’s direction, so I substracted the direction from the hit point. However, in environment map, the direction is <em>towards</em> the light, so I need to add them instead of substracting. After fixing this, the result looked pretty nice:</p>
<figure>
<img src="./assets/sphere_env_light_biased_sampling.png" alt="Mostly Correct Sphere under Environment Light" />
<figcaption aria-hidden="true">Mostly Correct Sphere under Environment Light</figcaption>
</figure>
<p>The next case I tried was the head. It looks soooooooooo nice! I also tried it with different sampling rates: 1, 4, 9, 25, 64, 81, 256, 400, 625, 900. I also created an animated GIF showing the improvement with increasing sampling rate.</p>
<figure>
<img src="./assets/head_env_light_biased.gif" alt="Improving Head under Environment Light" />
<figcaption aria-hidden="true">Improving Head under Environment Light</figcaption>
</figure>
<p>The result is a bit off, and it also do not use smooth shading, but the progression looks very nice.</p>
<p>I also tried the end of homework boss: Audi.</p>
<figure>
<img src="./assets/audi-tt-glacier_texture_error.png" alt="Wrong Audi under Glacier Environment Light" />
<figcaption aria-hidden="true">Wrong Audi under Glacier Environment Light</figcaption>
</figure>
<p>Do you see the problem? The car has a 『　　』<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> plate! After some debugging, I found out that some texture coordinates were negative, which broke the program. I used wrapping instead of clamping in texture coordinates and the result became mostly correct.</p>
<figure>
<img src="./assets/audi-tt-glacier_inverse_map_instead_of_rejection.png" alt="Mostly Correct Audi under Glacier Environment Light" />
<figcaption aria-hidden="true">Mostly Correct Audi under Glacier Environment Light</figcaption>
</figure>
<p>So, the homework is done! I fixed up the sampling, whose results are in the <a href="#results">results</a>.</p>
<h1 id="results">Results</h1>
<figure>
<img src="./assets/audi-tt-glacier.png" alt="Correct Audio under Glacier Environment Light except Noise" />
<figcaption aria-hidden="true">Correct Audio under Glacier Environment Light except Noise</figcaption>
</figure>
<figure>
<img src="./assets/audi-tt-pisa.png" alt="Correct Audio under Pisa Environment Light except Noise" />
<figcaption aria-hidden="true">Correct Audio under Pisa Environment Light except Noise</figcaption>
</figure>
<figure>
<img src="./assets/empty_environment_latlong.png" alt="Empty Environment with LatLong Texture" />
<figcaption aria-hidden="true">Empty Environment with LatLong Texture</figcaption>
</figure>
<figure>
<img src="./assets/empty_environment_light_probe.png" alt="Empty Environment with Probe Texture" />
<figcaption aria-hidden="true">Empty Environment with Probe Texture</figcaption>
</figure>
<figure>
<img src="./assets/glass_sphere_env.png" alt="Spherical Glass under Environment Light" />
<figcaption aria-hidden="true">Spherical Glass under Environment Light</figcaption>
</figure>
<figure>
<img src="./assets/mirror_sphere_env.png" alt="Spherical Mirror under Environment Light" />
<figcaption aria-hidden="true">Spherical Mirror under Environment Light</figcaption>
</figure>
<h1 id="performance">Performance</h1>
<p>First, the benchmark between virtual and variant. Since <code>std::variant</code>’s implementation can dramatically change between the compilers, I also tested between compilers.</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 18%" />
<col style="width: 19%" />
<col style="width: 18%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr>
<th>Testcase</th>
<th>Rendering Time (GCC, virtual)</th>
<th>Rendering Time (MSVC, virtual)</th>
<th>Rendering Time (GCC, variant)</th>
<th>Rendering Time (MSVC, variant)</th>
</tr>
</thead>
<tbody>
<tr>
<td>bunny.xml</td>
<td>0.0283802</td>
<td>0.0458557</td>
<td>0.0287202</td>
<td>0.0468452</td>
</tr>
<tr>
<td>cornellbox_recursive.xml</td>
<td>0.229955</td>
<td>0.36028</td>
<td>0.238443</td>
<td>0.371436</td>
</tr>
<tr>
<td>other_dragon.xml</td>
<td>0.361675</td>
<td>0.526551</td>
<td>0.361571</td>
<td>0.525055</td>
</tr>
<tr>
<td>scienceTree_glass.xml</td>
<td>0.463028</td>
<td>0.852566</td>
<td>0.478199</td>
<td>0.870111</td>
</tr>
<tr>
<td>simple.xml</td>
<td>0.0219692</td>
<td>0.0374878</td>
<td>0.0220329</td>
<td>0.0400985</td>
</tr>
<tr>
<td>two_spheres.xml</td>
<td>0.0210437</td>
<td>0.0283466</td>
<td>0.0223661</td>
<td>0.0281506</td>
</tr>
<tr>
<td>instance/ellipsoids.xml</td>
<td>0.0788359</td>
<td>0.119194</td>
<td>0.081917</td>
<td>0.122259</td>
</tr>
<tr>
<td>instance/metal_glass_plates.xml</td>
<td>0.664058</td>
<td>1.11338</td>
<td>0.677238</td>
<td>1.15823</td>
</tr>
<tr>
<td>instance/spheres.xml</td>
<td>0.0556113</td>
<td>0.0909408</td>
<td>0.0594592</td>
<td>0.094961</td>
</tr>
<tr>
<td>dist/cornellbox_area.xml</td>
<td>8.36556</td>
<td>14.7246</td>
<td>9.2073</td>
<td>15.0258</td>
</tr>
<tr>
<td>dist/focusing_dragons.xml</td>
<td>38.455</td>
<td>58.5525</td>
<td>33.8644</td>
<td>58.6734</td>
</tr>
<tr>
<td>dist/spheres_dof.xml</td>
<td>5.44902</td>
<td>8.11655</td>
<td>5.78713</td>
<td>8.19425</td>
</tr>
<tr>
<td>texture/bump_mapping_transformed.xml</td>
<td>0.121709</td>
<td>0.139171</td>
<td>0.131904</td>
<td>0.148202</td>
</tr>
<tr>
<td>texture/brickwall_with_normalmap.xml</td>
<td>0.0846417</td>
<td>0.16104</td>
<td>0.0862123</td>
<td>0.165274</td>
</tr>
<tr>
<td>texture/cube_cushion.xml</td>
<td>0.083873</td>
<td>0.157696</td>
<td>0.0838197</td>
<td>0.16078</td>
</tr>
<tr>
<td>texture/cube_perlin.xml</td>
<td>0.12215</td>
<td>0.275763</td>
<td>0.124521</td>
<td>0.272554</td>
</tr>
<tr>
<td>texture/cube_perlin_bump.xml</td>
<td>0.138111</td>
<td>0.292683</td>
<td>0.137821</td>
<td>0.294797</td>
</tr>
<tr>
<td>texture/cube_wall.xml</td>
<td>0.0778775</td>
<td>0.152509</td>
<td>0.0790112</td>
<td>0.156742</td>
</tr>
<tr>
<td>texture/cube_wall_normal.xml</td>
<td>0.0841438</td>
<td>0.159097</td>
<td>0.0866704</td>
<td>0.163564</td>
</tr>
<tr>
<td>texture/cube_waves.xml</td>
<td>0.0809337</td>
<td>0.157239</td>
<td>0.0843926</td>
<td>0.162292</td>
</tr>
<tr>
<td>texture/ellipsoids_texture.xml</td>
<td>0.0771365</td>
<td>0.117501</td>
<td>0.0793805</td>
<td>0.118619</td>
</tr>
<tr>
<td>texture/galactica_static.xml</td>
<td>0.367829</td>
<td>0.72849</td>
<td>0.376033</td>
<td>0.738424</td>
</tr>
<tr>
<td>texture/killeroo_bump_walls.xml</td>
<td>0.26567</td>
<td>0.459497</td>
<td>0.270957</td>
<td>0.466517</td>
</tr>
<tr>
<td>texture/plane_bilinear.xml</td>
<td>0.0220511</td>
<td>0.0301912</td>
<td>0.0278078</td>
<td>0.0332584</td>
</tr>
<tr>
<td>texture/sphere_nearest_bilinear.xml</td>
<td>0.0813739</td>
<td>0.0842668</td>
<td>0.0894229</td>
<td>0.0906545</td>
</tr>
<tr>
<td>texture/sphere_nobump_bump.xml</td>
<td>0.0874026</td>
<td>0.0945517</td>
<td>0.0956179</td>
<td>0.101027</td>
</tr>
<tr>
<td>texture/sphere_nobump_justbump.xml</td>
<td>0.0889195</td>
<td>0.0929987</td>
<td>0.0929962</td>
<td>0.0978418</td>
</tr>
<tr>
<td>texture/sphere_perlin.xml</td>
<td>0.126511</td>
<td>0.135037</td>
<td>0.14301</td>
<td>0.144179</td>
</tr>
<tr>
<td>texture/sphere_perlin_bump.xml</td>
<td>0.155357</td>
<td>0.163569</td>
<td>0.160708</td>
<td>0.165377</td>
</tr>
<tr>
<td>texture/sphere_perlin_scale.xml</td>
<td>0.129742</td>
<td>0.136017</td>
<td>0.143759</td>
<td>0.145046</td>
</tr>
<tr>
<td>texture/wood_box.xml</td>
<td>0.0785099</td>
<td>0.153957</td>
<td>0.0816696</td>
<td>0.158564</td>
</tr>
<tr>
<td>texture/wood_box_all.xml</td>
<td>0.0929561</td>
<td>0.170726</td>
<td>0.0971621</td>
<td>0.175384</td>
</tr>
<tr>
<td>texture/wood_box_no_specular.xml</td>
<td>0.0772033</td>
<td>0.151232</td>
<td>0.0813137</td>
<td>0.156096</td>
</tr>
<tr>
<td>texture/dragon/dragon_new_ply.xml</td>
<td>2.40284</td>
<td>4.72215</td>
<td>2.449</td>
<td>4.68368</td>
</tr>
</tbody>
</table>
<figure>
<img src="./assets/plot_variant_virtual_big.png" alt="Variant vs Virtual" />
<figcaption aria-hidden="true">Variant vs Virtual</figcaption>
</figure>
<p>As always, I removed the biggest case, Focusing Dragons in this case, and created a graph with less scale issues.</p>
<figure>
<img src="./assets/plot_variant_virtual.png" alt="Variant vs Virtual without Focusing Dragons" />
<figcaption aria-hidden="true">Variant vs Virtual without Focusing Dragons</figcaption>
</figure>
<p>And here is comparison between multisampled environment light testcases, the head case having increasing number of samples. I also tested with non-uniform sampling I used at first, and rejection sampling I right before submission.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 8%" />
<col style="width: 33%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Testcase</th>
<th>Init Time</th>
<th>Rendering Time (Non-Uniform Sampling)</th>
<th>Rendering Time (Rejection Sampling) (1 run)</th>
</tr>
</thead>
<tbody>
<tr>
<td>head_env_light_1.xml</td>
<td>0.480417</td>
<td>0.0863338</td>
<td>0.094445</td>
</tr>
<tr>
<td>head_env_light_4.xml</td>
<td>0.482032</td>
<td>0.324461</td>
<td>0.35339</td>
</tr>
<tr>
<td>head_env_light_9.xml</td>
<td>0.480289</td>
<td>0.713553</td>
<td>0.77416</td>
</tr>
<tr>
<td>head_env_light_25.xml</td>
<td>0.478837</td>
<td>1.93651</td>
<td>2.1619</td>
</tr>
<tr>
<td>head_env_light_64.xml</td>
<td>0.48009</td>
<td>4.91133</td>
<td>5.3379</td>
</tr>
<tr>
<td>head_env_light_81.xml</td>
<td>0.478714</td>
<td>6.17004</td>
<td>6.4833</td>
</tr>
<tr>
<td>head_env_light_256.xml</td>
<td>0.479881</td>
<td>19.1987</td>
<td>20.162</td>
</tr>
<tr>
<td>head_env_light_400.xml</td>
<td>0.478432</td>
<td>29.877</td>
<td>20.162</td>
</tr>
<tr>
<td>head_env_light_625.xml</td>
<td>0.479133</td>
<td>46.5023</td>
<td>49.161</td>
</tr>
<tr>
<td>head_env_light_900.xml</td>
<td>0.480646</td>
<td>67.1025</td>
<td>70.671</td>
</tr>
<tr>
<td>audi-tt-glacier (1 run)</td>
<td>4.0886</td>
<td>92.344</td>
<td>92.504</td>
</tr>
<tr>
<td>audi-tt-pisa (1 run)</td>
<td>1.0195</td>
<td>92.594</td>
<td>100.36</td>
</tr>
</tbody>
</table>
<p>For this, I created a line graph for Head case instead, for which no Audi case being used.</p>
<figure>
<img src="./assets/plot_head_sampling.png" alt="Head Environment Light Time by Sample Count" />
<figcaption aria-hidden="true">Head Environment Light Time by Sample Count</figcaption>
</figure>
<p>I guess the non-linearity of the rejection sampling is actually caused by the lack of run samples, since it is run once instead of 10 times.</p>
<p>And finally, the new cases. Note that Audi cases differ considerably, the reason of which I have not been able to find. I might have used my computer a bit while rendering Pisa one, but I am not sure.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 28%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th>Testcase</th>
<th>Initialization Time</th>
<th>Rendering Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>cube_directional.xml</td>
<td>0.00107759</td>
<td>0.0486516</td>
</tr>
<tr>
<td>cube_point_hdr.xml</td>
<td>0.00112352</td>
<td>0.0476622</td>
</tr>
<tr>
<td>cube_point.xml</td>
<td>0.00107655</td>
<td>0.0472609</td>
</tr>
<tr>
<td>cube_spot.xml</td>
<td>0.00111161</td>
<td>0.697898</td>
</tr>
<tr>
<td>dragon_spot_light_msaa.xml</td>
<td>0.793014</td>
<td>12.9384</td>
</tr>
<tr>
<td>empty_environment_latlong.xml</td>
<td>0.026575</td>
<td>0.00820551</td>
</tr>
<tr>
<td>empty_environment_light_probe.xml</td>
<td>0.0290373</td>
<td>0.00723625</td>
</tr>
<tr>
<td>glass_sphere_env.xml</td>
<td>0.194476</td>
<td>0.0978511</td>
</tr>
<tr>
<td>head_env_light.xml</td>
<td>0.488338</td>
<td>70.671</td>
</tr>
<tr>
<td>mirror_sphere_env.xml</td>
<td>0.193074</td>
<td>0.0273269</td>
</tr>
<tr>
<td>sphere_env_light.xml</td>
<td>0.345325</td>
<td>14.0511</td>
</tr>
<tr>
<td>sphere_point_hdr_texture.xml</td>
<td>0.193863</td>
<td>0.0319999</td>
</tr>
<tr>
<td>audi-tt-glacier (1 run)</td>
<td>3.7497</td>
<td>92.504</td>
</tr>
<tr>
<td>auto-tt-pisa (1 run)</td>
<td>4.2037</td>
<td>100.36</td>
</tr>
</tbody>
</table>
<figure>
<img src="./assets/plot_hdr.png" alt="Times of New Cases" />
<figcaption aria-hidden="true">Times of New Cases</figcaption>
</figure>
<figure>
<img src="./assets/plot_hdr_stacked.png" alt="Times of New Cases (Stacked)" />
<figcaption aria-hidden="true">Times of New Cases (Stacked)</figcaption>
</figure>
<p>As usual, here is the graph without Audi and head cases, which break the scale.</p>
<figure>
<img src="./assets/plot_hdr_small.png" alt="Times of New Cases without Audis" />
<figcaption aria-hidden="true">Times of New Cases without Audis</figcaption>
</figure>
<figure>
<img src="./assets/plot_hdr_stacked_small.png" alt="TImes of New Cases without Audis" />
<figcaption aria-hidden="true">TImes of New Cases without Audis</figcaption>
</figure>
<h1 id="conclusion">Conclusion</h1>
<p>Yet another homework, and again something easy while being definitely non-trivial. I am yet again thankful for these homeworks, these homeworks actually teach me (and probably most of us) writing maintainable software in suitable deadlines much better than term projects. I do not feel that I am doing work in term project, it is unnecessarily too bureucratic while giving almost no benefit to the project itself. However, even though we are doing these homeworks alone, they teach me writing good software practices better. The AGILE approach emphasizes constant refactoring, and I do this in homeworks but not the term project, where we use AGILE as the official software engineering method. I think that developing such applications in such a long timespan (compared to the other homeworks we have done in the other courses) means that we are actually not writing alone, since the me two weeks later can actually be considered as a different person. The constant refactor and the implicit need for writing maintainable software is such an educating experience while being so entertaining!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Yet another anime/manga/light novel reference! However, this time, it is from a less controversial one named <a href="https://anilist.co/manga/78399/No-Game-No-Life">No Game No Life</a>. The main characters (an elder brother named Sora and a little sister named Shiro) use the nickname 『　　』 in games, read as Kuuhaku. They both are pretty much geniuses in gaming, playing games almost the whole day without seeing a single ray of the Sun and having literally no single instance of defeat. They would then be summoned to another world where everything from thefts to wars between polities being done with games, ranging from backgammon to VR FPS games. The name is actually the combination of the characters’ names, <ruby>空<rp>(</rp><rt>Sora</rt><rp>)</rp></ruby> and <ruby>白<rp>(</rp><rt>Shiro</rt><rp>)</rp></ruby>. When both of these Kanjis are concatenated, it becomes <ruby>空<rp>(</rp><rt>Kuu</rt><rp>)</rp></ruby><ruby>白<rp>(</rp><rt>haku</rt><rp>)</rp></ruby>, which means “blank” in Japanese. The brother’s name means “empty, sky” and the sister’s name means “white”, so the name can roughly be translated as “whitespace”, which is also another usage of this word, e.g. on keyboards.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
	</article>

	<div id="metadata">
		<div id="navigation">
			<h1>Site</h1>
			<ul>
				<li><a href="/about">Hakkımda</a></li>
				<li><a href="/gönderiler">Gönderiler</a></li>
				<li><a href="/etiketler">Etiketler</a></li>
			</ul>
		</div>

				<hr/>
		<div id="table-of-contents">
			<h1>İçindekiler</h1>
			<ul>
<li><a href="#implementation" id="toc-implementation">Implementation</a>
<ul>
<li><a href="#material-refactor" id="toc-material-refactor">Material Refactor</a></li>
<li><a href="#directional-lights" id="toc-directional-lights">Directional Lights</a></li>
<li><a href="#spot-light" id="toc-spot-light">Spot Light</a></li>
<li><a href="#tonemapping" id="toc-tonemapping">Tonemapping</a></li>
<li><a href="#hdr-environment-map" id="toc-hdr-environment-map">HDR Environment Map</a></li>
</ul></li>
<li><a href="#results" id="toc-results">Results</a></li>
<li><a href="#performance" id="toc-performance">Performance</a></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul>
		</div>
		
				<hr/>
		<div id="time">
			<h1>Gönderilme Zamanı</h1>
			<ul>
				<li>
					<time><a href="/gönderiler/2024">2024</a>-<a href="/gönderiler/2024/12">12</a>-29 23:39:24+03:00</time>
				</li>
			</ul>
		</div>
		
				<hr/>
		<div id="tags">
			<h1>Etiketler</h1>
			<ul>
								<li><a href="/etiketler/C++">C++</a></li>
								<li><a href="/etiketler/Programlama">Programlama</a></li>
								<li><a href="/etiketler/Teknoloji">Teknoloji</a></li>
								<li><a href="/etiketler/Gönderi">Gönderi</a></li>
								<li><a href="/etiketler/Ödev">Ödev</a></li>
								<li><a href="/etiketler/Işın İzleme">Işın İzleme</a></li>
							</ul>
		</div>
		
	</div>

</div>

<footer>
	<div id="copyup">© Erencan Ceyhan, 2025</div>
	<div id="links">
		<a href="https://github.com/erenjanje">GitHub</a>
		<a href="https://www.linkedin.com/in/erencan-ceyhan/">LinkedIn</a>
		<a href="mailto:erencan.ceyhan@hotmail.com">E-Posta</a>
	</div>
</footer>
</body>
</html>