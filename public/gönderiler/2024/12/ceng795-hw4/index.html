<!DOCTYPE html>
<html  lang="en" >
<head>
	<meta charset="UTF-8"/>
		<meta name="author" content="Erencan Ceyhan"/>
			<meta name="keywords" content="C++, Programlama, Teknoloji, Gönderi, Ödev, Işın İzleme"/>
		<title>CENG795-HW4: Raytracing with Textures</title>
	<link href="/style/index.css" rel="stylesheet"/>
</head>
<body>

<div id="header">
	<a id="site-header" href="/"><h1>Erencan'ın Köşesi</h1></a>

	<div id="page-header">
		<h1>CENG795-HW4: Raytracing with Textures</h1>
	</div>
</div>

<div id="content">

	<article class="card">
		<ul>
<li><a href="#reimplementation-failure">Reimplementation (Failure)</a></li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#diffuse-and-specular-textures">Diffuse and Specular Textures</a></li>
<li><a href="#noise-and-checkerboard">Noise and Checkerboard</a></li>
<li><a href="#normal-and-bump-mapping">Normal and Bump Mapping</a></li>
</ul></li>
<li><a href="#results">Results</a></li>
<li><a href="#performance">Performance</a>
<ul>
<li><a href="#compiler-benchmark">Compiler Benchmark</a></li>
<li><a href="#texture-benchmark">Texture Benchmark</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<p>Welcome again to my blog post about yet another CENG795 homework, minasan! I think my recovery from my failure of the HW2 is pretty much done, now I implement the homeworks on time, and even, sometime before the deadline. Actually, in this homework, I managed to finish the homework about 3 days early except a small fix to sphere tangent/bitangent calculation, while using almost half of the time (about 1 week) to something I did in vain.</p>
<h1 id="reimplementation-failure">Reimplementation (Failure)</h1>
<p>As I said in the previous paragraph, my first week was doing something that I did not use at all: reimplementing the whole raytracer from scratch. I had actually been thinking reimplementation since HW2; however, unfortunately, things did not go according to my plan and I had to postpone any consideration of reimplementation. Yet in the implementation of HW4, I actually had time to waste in reimplementation. There were two reasons of why I wanted reimplementation: using a nicer language (since C++ is pretty bad in terms of programming language design, and it also has abysmal compilation times) and fixing a few design choices I did that started to get in my way. Since performance is top priority in raytracing, any pure interpreted language like Python (which has JIT compiler PyPy but its performance is also not that bright) is out of question. Since Rust and Haskell had been used in this course before, I did not want to use them since I wanted to use a “new” language, a language that has not been used in this course. Losing Rust to this silly thought has been pretty bad for the choice of language. The language also should be something I am at least a bit familiar with. This also filtered Java and OcaML. The current languages were C, C#, Lua (with LuaJIT) and JS/TS (on browser). Since I would probably debug segfaults more than my raytracer, I eliminated C. All of these remaining languages are pretty nice ones, so I started the reimplementation. I also thought about the nice-to-haves in those languages, and Lua was better than C# due to having <a href="https://love2d.org">LÖVE</a>, which can be run on both desktop and mobile devices, and provides a nice layer on top of SDL, and OpenGL to some extent. It also comes with LuaJIT as default. However, JS/TS is even better since everybody and their brother/uncle/mother has a browser, which makes the distribution (not the HW3) much less of a hassle. So, I started to reimplement the raytracer in TS, but after implementing some parts, I failed to use the modules (since JS has the worst module system in the world, even worse than C). At that point, almost half of the first week had passed, so I panicked and dropped my first reimplementation reason: a nicer language.</p>
<p>Afterwards, I dumped the TS implementation and started the reimplementation on C++. I did this so that I could share code with my existing implementation, I was pretty fine with the ray creation or ray-triangle intersection codes after all. However, as I rewrote the parser, I realized that in that pace, I would miss the deadline for HW4, since it took a whole day to reimplement the parser, <em>with a few features missing</em>. The code itself also became mostly non-interoperable with my previous ray-tracer since I changed most data structures. For example, the materials were classes with <code>virtual</code> methods instead of <code>std::variant</code>s since C++ has one of the worst sum-type support while the <code>virtual</code> is one of the best things in C++. Most of the data structures also held references to the data they need (e.g. meshes held references to the vertex array, since the mesh data is in indices instead of raw vectors). This made interoperation with my previous code pretty much impossible except rewriting a huge part of the older one, which just meant almost a total rewrite, for which I did not have time. At that point, the first week already passed and I was yet to start the HW4, while also being somewhat tired of the raytracer. Erencan is Done For!<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>As the second week started, I just discarded the whole adventure of reimplementation and started to refactor some parts of my existing raytracer instead. Since HW4 does not have too much need to fiddle with the materials, I just postponed material refactor to another time and refactored the build system, folder structure and the parser. Since the parser cosists of repeated code like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Get ShadowRayEpsilon</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>element <span class="op">=</span> root<span class="op">-&gt;</span>FirstChildElement<span class="op">(</span><span class="st">&quot;ShadowRayEpsilon&quot;</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>element<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    stream <span class="op">&lt;&lt;</span> element<span class="op">-&gt;</span>GetText<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    stream <span class="op">&lt;&lt;</span> <span class="st">&quot;0.001&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>stream <span class="op">&gt;&gt;</span> ret<span class="op">.</span>shadow_ray_epsilon<span class="op">;</span></span></code></pre></div>
<p>I wrapped up this as a templated function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> T get<span class="op">(</span><span class="at">const</span> tinyxml2<span class="op">::</span>XMLElement<span class="op">*</span> element<span class="op">,</span> <span class="bu">std::</span>stringstream<span class="op">&amp;</span> ss<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>element <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Error: element is null&quot;</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret <span class="op">=</span> T<span class="op">();</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    ss <span class="op">&lt;&lt;</span> element<span class="op">-&gt;</span>GetText<span class="op">();</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    ss <span class="op">&gt;&gt;</span> ret<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    ss<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Of course <code>glm::vec</code>s cannot be read from a stream, so I defined the <code>operator&gt;&gt;</code>s for them, which just read from the stream to the fields of the vectors. I also created an overload of <code>get&lt;T&gt;</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> T get<span class="op">(</span><span class="at">const</span> tinyxml2<span class="op">::</span>XMLElement<span class="op">*</span> element<span class="op">,</span> <span class="bu">std::</span>stringstream<span class="op">&amp;</span> ss<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> default_value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>element <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> default_value<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret <span class="op">=</span> T<span class="op">();</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    ss <span class="op">&lt;&lt;</span> element<span class="op">-&gt;</span>GetText<span class="op">();</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    ss <span class="op">&gt;&gt;</span> ret<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    ss<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This returns the <code>default_value</code> instead of throwing an error when the element is not found, which is pretty useful for optional fields, such as <code>BackgroundColor</code>, which I assume to be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 0, 0]</annotation></semantics></math> as default.</p>
<p>Rewriting most of the parser to use this was pretty easy, I just removed the old code (as in the example I gave for <code>ShadowRayEpsilon</code>) and replaced with a <code>get&lt;T&gt;</code> call with suitable type as the template parameter. However, there was a small problem, that some fields (like <code>ImageName</code> for <code>Camera</code> and <code>Transformations</code> for <code>Mesh</code>/<code>Triangle</code>/<code>Sphere</code>) needs the whole text of the element, and <code>stream &gt;&gt; str</code> where <code>str</code> is an <code>std::string</code> reads until the first whitespace, which is not usable since filenames may have spaces, and transformations definitely have spaces separating them. Hence, I created a small full template specialization:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string get<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span><span class="at">const</span> tinyxml2<span class="op">::</span>XMLElement<span class="op">*</span> element<span class="op">,</span> <span class="bu">std::</span>stringstream<span class="op">&amp;)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>element <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Error: element is null&quot;</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> element<span class="op">-&gt;</span>GetText<span class="op">();</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>stringstream</code> is not needed since the returned value is the whole text itself, which is why I did not give name for the second parameter. However, it is needed to be there since it is not an overload but a specialization.</p>
<p>This rewrite decreased the number of lines from 580 to 462 while also fixing a small bug that had been there in my implementation since HW1: some cases have the image plane distance as the fifth value in the <code>NearPlane</code> field, which broke the old code since it did not clear the <code>stringstream</code> after reading <code>NearPlane</code>, which offsets every value after it.</p>
<p>As I said, I also refactored the folder tree and changed the build system. Since HW1, I used a modified version of my <a href="https://erencanc.pages.dev/files/GenericMakefile/Makefile">generic Makefile</a>, which handles recursive source tree pretty well. However, mixing release and debug builds was horrible, since both of them put their object files to the same place. This meant that if I compile the program with debug mode, change one file and recompile with release mode, the program I get would be a chimera of release and debug builds, with only the changed file’s corresponding object file being in release mode. In previous homeworks, whenever I needed to debug using GDB, I needed to recompile everything. After solving the problem, I needed to recompile everything again using release mode to get the output image in a reasonable time (to check the overall image). This development loop was a real headache for me. However, thanks to CMake, I do not and will not have this! I divided the program into some modules (bvh, glm, math, parser, scene, shading, stb and tinyxml), which are compiled on their own and the whole program is linked at the last step, the usual compilation pipeline. I struggled with CMake at first, but the whole compilation pipeline became a breeze after I did it. After a week of HW4 implementation, I can confidently say that this improved my see-debug-fix-see loop substantially. I probably spent half of time per an instance of that loop compared to my generic Makefile. Furthermore, there is a very nice side effect: now I can compile my program on MSVC <a href="assets/For%20free.mp4">for free</a>! I mentioned this before but, I did a small benchmark between GCC and MSVC.</p>
<p>I also created a small Lua script to automatize some work, like running a testcase 10 times and taking the geometric mean. It even outputs a Markdown table automatically, so that I can just copy-paste the output of the script to my post!</p>
<p><a href="#compiler-benchmark">Click here</a> to get to the benchmark results section, which I did thanks to these conveniences.</p>
<h1 id="implementation">Implementation</h1>
<p>Finally, I can start doing the homework! Implementing texture support was actually pretty easy, except for bump mapping.</p>
<p>The first thing I did was to decide on the architecture of the textures. Textures come with three flavors: image, noise and checkerboard. This is perfect for sum-types, but C++ <code>std::variant</code> is one of the worst sum-type implementations. Hence, I went with <code>virtual</code> methods instead.</p>
<p>There is however a small problem, that a derived class pointer/reference cannot be cast to a base class one <em>if the base class is not a direct parent of the derived class</em>. This means that something like this is illegal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{};</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> B <span class="op">:</span> <span class="kw">public</span> A <span class="op">{};</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C <span class="op">:</span> <span class="kw">public</span> B <span class="op">{};</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c <span class="op">=</span> <span class="kw">new</span> C<span class="op">();</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">*</span> a <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Actually, this exact code is not illegal, but for some reason, while I was reimplementing the materials, I came across such a problem. This is why the real concrete classes, <code>ImageTexture</code>, <code>NoiseTexture</code> and <code>CheckerboardTexture</code> are actually just child of data (<code>DImageTexture</code>, <code>DNoiseTexture</code> and <code>DCheckerboardTexture</code>) and interface (<code>ITexture</code>) classes in my code. However, I do not have a problem with this that much, since this separates the data and the implementation pretty well. <code>D*Texture</code> classes (actually <code>struct</code>s since I do not use <code>class</code> keyword) are pretty much POD structs, which is very nice.</p>
<p>The texture interface, defined in <code>ITexture</code> is this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ITexture <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> glm<span class="op">::</span>vec3 sample<span class="op">(</span>glm<span class="op">::</span>vec3 tex_coords<span class="op">,</span> <span class="dt">float</span> lambda <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> DecalMode get_decal_mode<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">bool</span> needs_world_coord<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> glm<span class="op">::</span>vec2 get_derivative<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">float</span> get_bump_factor<span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> glm<span class="op">::</span>vec3 get_gradient<span class="op">(</span>glm<span class="op">::</span>vec3 position<span class="op">,</span> <span class="dt">float</span> factor<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Some of these methods are probably redundant and can be removed, but I just put them there. This is how you get technical debt, Erencan!</p>
<p>As you can see, <code>get_gradient</code> is actually not an abstract method. Since getting the gradient for noise/checkerboard needs only sampling, I thought that using the base class not only as an interface but also as something like a mixin (not exactly such but a similar thing). It has an implementation like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> epsilon <span class="op">=</span> <span class="fl">1e-3</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> f <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span>factor <span class="op">/</span> <span class="fl">3.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> h <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>sample<span class="op">(</span>position<span class="op">),</span> f<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> h_x <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>sample<span class="op">(</span>position <span class="op">+</span> glm<span class="op">::</span>vec3<span class="op">(</span>epsilon<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)),</span> f<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> h_y <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>sample<span class="op">(</span>position <span class="op">+</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="dv">0</span><span class="op">,</span> epsilon<span class="op">,</span> <span class="dv">0</span><span class="op">)),</span> f<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> h_z <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>sample<span class="op">(</span>position <span class="op">+</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> epsilon<span class="op">)),</span> f<span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> glm<span class="op">::</span>vec3<span class="op">((</span>h_x <span class="op">-</span> h<span class="op">)</span> <span class="op">/</span> epsilon<span class="op">,</span> <span class="op">(</span>h_y <span class="op">-</span> h<span class="op">)</span> <span class="op">/</span> epsilon<span class="op">,</span> <span class="op">(</span>h_z <span class="op">-</span> h<span class="op">)</span> <span class="op">/</span> epsilon<span class="op">);</span></span></code></pre></div>
<p>This function will be needed in bump mapping for noise/checkerboard, but not yet of course.</p>
<p>Thanks to the <code>get&lt;T&gt;</code> functions, parsing the textures was very easy. However, I wanted to improve them a bit and specialized both default and non-default (throwing) ones for <code>DecalMode</code>, <code>InterpolationMode</code> and <code>NoiseConversion</code> (<code>Normalization</code> in my code). They are pretty small, consisting of a handful of <code>if</code> statements, but they look very nice in the main parser code since I can just call <code>get&lt;DecalMode&gt;()</code> etc. The following is <code>get&lt;InterpolationMode&gt;</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>InterpolationMode get<span class="op">&lt;</span>InterpolationMode<span class="op">&gt;(</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> tinyxml2<span class="op">::</span>XMLElement<span class="op">*</span> element<span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stringstream<span class="op">&amp;</span> ss<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> InterpolationMode<span class="op">&amp;</span> default_value</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>element <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> default_value<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> str <span class="op">=</span> get<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>element<span class="op">,</span> ss<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>str <span class="op">==</span> <span class="st">&quot;nearest&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> InterpolationMode<span class="op">::</span>Nearest<span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>str <span class="op">==</span> <span class="st">&quot;bilinear&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> InterpolationMode<span class="op">::</span>Bilinear<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>str <span class="op">==</span> <span class="st">&quot;trilinear&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;-- TRILINEAR DETECTED</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> InterpolationMode<span class="op">::</span>Trilinear<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Unrecognized InterpolationMode: &quot;</span> <span class="op">+</span> str<span class="op">);</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="diffuse-and-specular-textures">Diffuse and Specular Textures</h2>
<p>After parsing texture coordinates (which reside besides their respective vertex position data), I was ready for textures. However, my first output was this:</p>
<figure>
<img src="assets/cube_wall_coordinates.png" alt="Cube Wall with Error" />
<figcaption aria-hidden="true">Cube Wall with Error</figcaption>
</figure>
<p>The texture looks correct, but the mapping looks wrong. It seems like some coordinates are swapped with each other. In order to test my hypothesis, I showed the UV coordinates instead of shading output (something I almost always do when I start a new OpenGL project), and the result shows the error by itself:</p>
<figure>
<img src="assets/cube_wall_uv.png" alt="Cube Wall with Only UV Coordinates" />
<figcaption aria-hidden="true">Cube Wall with Only UV Coordinates</figcaption>
</figure>
<p>Since I became sure about the error, I started experimenting. Since the coordinates are swapped, I started swapping the barycentric coordinates around with each other. I was using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> for UV0, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> for UV1 and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math> for UV2. However, after some trial and error, I found out that in my case, the correct order was <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math> for UV0, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> for UV1 and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math> for UV2. I don’t know the reason of this, but this is how it works. After fixing this, the UV coordinates became correct.</p>
<figure>
<img src="assets/cube_wall_uv_correct.png" alt="Cube Wall with Correct UV Coordinates" />
<figcaption aria-hidden="true">Cube Wall with Correct UV Coordinates</figcaption>
</figure>
<p>Now, I only needed to test using real texture and voilà!</p>
<figure>
<img src="assets/cube_wall_nearest.png" alt="Cube Wall with Nearest Neighbor Sampling" />
<figcaption aria-hidden="true">Cube Wall with Nearest Neighbor Sampling</figcaption>
</figure>
<p>The only issue remaining for this testcase was that I used nearest neighbor sampling since I had been yet to implement bilinear sampling.</p>
<p>After this, I quickly implemented specular shading texture, which was pretty much the same with diffuse texture. The result was an almost pixel-perfect copy of the reference image.</p>
<figure>
<img src="assets/wood_box.png" alt="Wood Box with Diffuse and Specular Textures" />
<figcaption aria-hidden="true">Wood Box with Diffuse and Specular Textures</figcaption>
</figure>
<p>The next thing I did was implementing bilinear sampling. Implementing it was pretty easy, but I forgot to make the weights <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">1 - dist</annotation></semantics></math> instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dist</annotation></semantics></math>, which resulted in a bit weird images:</p>
<figure>
<img src="assets/cube_wall_wrong_bilinear.png" alt="Cube Wall with Wrong Bilinear Sampling" />
<figcaption aria-hidden="true">Cube Wall with Wrong Bilinear Sampling</figcaption>
</figure>
<figure>
<img src="assets/plane_bilinear_wrong.png" alt="Plane with Wrong Bilinear Sampling" />
<figcaption aria-hidden="true">Plane with Wrong Bilinear Sampling</figcaption>
</figure>
<p>When I fixed it, the results became pretty much the pixel perfect copies of the reference images:</p>
<figure>
<img src="assets/cube_wall_correct.png" alt="Cube Wall with Correct Bilinear Sampling" />
<figcaption aria-hidden="true">Cube Wall with Correct Bilinear Sampling</figcaption>
</figure>
<figure>
<img src="assets/plane_bilinear_correct.png" alt="Plane with Correct Bilinear Sampling" />
<figcaption aria-hidden="true">Plane with Correct Bilinear Sampling</figcaption>
</figure>
<p>And here is the plane with nearest neighbor sampling for comparison of the aliasing artifacts.</p>
<figure>
<img src="assets/plane_nearest.png" alt="Plane with Nearest Neighbor Sampling" />
<figcaption aria-hidden="true">Plane with Nearest Neighbor Sampling</figcaption>
</figure>
<h2 id="noise-and-checkerboard">Noise and Checkerboard</h2>
<p>Now, I had pretty much two routes, either first implementing the noise and checkerboard and then implementing normal and bump mapping or vice versa. I went with the former one since I thought it would be easier, and yep, it really was pretty easy.</p>
<p>I searched for a nice Perlin noise implementation in C++ in the internet, since implementing it from scratch was too cumbersome and math-y for me. Unfortunately, I was unsuccessful in my searches; however, the hope was not lost. Two years before, I needed Perlin noise for volumetric clouds for HW3 of CENG469 and I found a nice GLSL implementation of Perlin noise. Due to the fact that GLSL is pretty much C on GPU, I managed to easily integrate the code to my C++ codebase. At first, I got segfaults, which suprised me but a quick debugging session (which is very easy thanks to CMake) revealed that negative inputs to the noise function resulted in negative index lookup in the permutation table. This suprised me since the indices were modulo’d by <code>256</code>, which means that they must be in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>255</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,255]</annotation></semantics></math> range, right? Well, this was a junior mistake but I really forgot that C’s modulo operator (and <code>div</code> instruction’s modulo result in x86-64) actually retains the sign of the number! This meant that <code>(-1) % 256</code> results in <code>-1</code>, not <code>255</code>. I thought about a fast and easy way to fix, but could not think a fast and dirty trick. However, since the right hand side of the modulo is a power of 2, that modulo operation most probably compiled to a bitwise and operation. Hence, I decided to use an easy trick. I took the modulo of the number, added <code>256</code> and took the modulo again. This must give the mathematically correct modulo, and it really did. I used a small macro to ease my development experience:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MODULUS</span><span class="op">(</span>a<span class="op">,</span><span class="pp"> </span>b<span class="op">)</span><span class="pp"> </span><span class="op">(((</span>a<span class="pp"> </span><span class="op">%</span><span class="pp"> </span>b<span class="op">)</span><span class="pp"> </span><span class="op">+</span><span class="pp"> </span>b<span class="op">)</span><span class="pp"> </span><span class="op">%</span><span class="pp"> </span>b<span class="op">)</span></span></code></pre></div>
<p>And this did the trick, I had working Perlin noise with only a couple of changes and minimal headache. Thank you two-years-younger-me! However, the result was a bit weird, the textures looked streched out compared to the reference images. Unfortunately, I cannot reproduce the exact bug at the moment and I do not have rendered images when that bug was there.</p>
<p>After some deduction from the lecture slides, I realized that the coordinates given to the noise and checkerboard are world coordinates, not UV coordinates. This explained my experience, what I did was pretty much creating a 2D noise texture and wrapping it around a sphere. Giving the world coordinates however utilizes a 3D noise texture, which looks better in a 3D scene. The results look pretty nice:</p>
<figure>
<img src="assets/cube_perlin.png" alt="Cubes with Noise" />
<figcaption aria-hidden="true">Cubes with Noise</figcaption>
</figure>
<figure>
<img src="assets/sphere_perlin.png" alt="Spheres with Noise" />
<figcaption aria-hidden="true">Spheres with Noise</figcaption>
</figure>
<figure>
<img src="assets/sphere_perlin_scale.png" alt="Spheres with Scaled Noise" />
<figcaption aria-hidden="true">Spheres with Scaled Noise</figcaption>
</figure>
<p>Unlike image textures, I pretty much cannot guarantee the pixel perfectness in noise textures, since the permutation I used is different than the one used by our instructor and there are just too many permutations to try to find the same one. However, the results look pretty similar in terms of looks. They really look like the same image with different noise seeds.</p>
<p>I also implemented the checkerboard texture by then, yet I could not test it since the only scene using it, Veach Ajar, had some unusual mesh and instance definition order, which my parser could not handle yet.</p>
<h2 id="normal-and-bump-mapping">Normal and Bump Mapping</h2>
<p>With this, I entered the final phase of the homework, changing the normals. Unlike the previous ones, the normal and bump maps modify the geometry (well, uhh, the normals) instead of the shading coefficients. Hence, I needed the textures in the ray casting procedure. Thankfully, I already needed it there due to the fact that I needed to get it from the material and give it to the material shading procedure, which means that the ray casting procedure (the middleman) already had the textures. However, I also needed tangent and bitangent vectors. Obtaining them was a pretty easy. Sphere one needs calculation at the intersection moment (since the vectors depend on the hit point) while triangles can be pre-calculated. I already used a method, <code>rt::triangle::calculateNormal</code>, to pre-calculate the normals from the edges at parse time. I utilized the same function to calculate not only the normal but also the tangent and bitangent vectors.</p>
<p>In the following formula, the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="bold">𝐄</mtext><mn>1</mn></msub><annotation encoding="application/x-tex">\textbf{E}_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="bold">𝐄</mtext><mn>2</mn></msub><annotation encoding="application/x-tex">\textbf{E}_2</annotation></semantics></math> are the difference between vertices 1 and 0, and 2 and 1, respectively. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐮𝐯</mtext><annotation encoding="application/x-tex">\textbf{uv}</annotation></semantics></math>s are the difference between UV coordinates of the vertices and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐓</mtext><annotation encoding="application/x-tex">\textbf{T}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐁</mtext><annotation encoding="application/x-tex">\textbf{B}</annotation></semantics></math> are tangent and bitangent vectors, respectively.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtext mathvariant="bold">𝐓</mtext><mspace width="1.0em"></mspace><mtext mathvariant="bold">𝐁</mtext><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="bold">𝐮𝐯</mtext><mn>1</mn></msub><mspace width="1.0em"></mspace><msub><mtext mathvariant="bold">𝐮𝐯</mtext><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="bold">𝐄</mtext><mn>1</mn></msub><mspace width="1.0em"></mspace><msub><mtext mathvariant="bold">𝐄</mtext><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
\left[\textbf{T}\quad\textbf{B}\right]
\left[\textbf{uv}_1\quad\textbf{uv}_2\right]=
\left[\textbf{E}_1\quad\textbf{E}_2\right]
</annotation></semantics></math></p>
<p>This is somewhat different than the formula in the lecture slides since this is column-major, which is the convention used by GLSL and GLM. After solving that equation by taking the inverse of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="bold">𝐮𝐯</mtext><mn>1</mn></msub><mspace width="1.0em"></mspace><msub><mtext mathvariant="bold">𝐮𝐯</mtext><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\left[\textbf{uv}_1\quad\textbf{uv}_2\right]</annotation></semantics></math> and multiplying it with from the right, I obtained tangent and bitangent.</p>
<p>Well, the normal mapping was pretty successful. In 3 lines, I got the normal mapping working.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> sample <span class="op">=</span> <span class="op">(</span>textures<span class="op">-&gt;</span>normal<span class="op">-&gt;</span>sample<span class="op">(</span>GET_CORRECT_POS<span class="op">(</span>textures<span class="op">-&gt;</span>normal<span class="op">,</span> uv<span class="op">,</span> hit_point<span class="op">))</span> <span class="op">-</span> <span class="fl">0.5</span><span class="bu">f</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> normalized_sample <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>sample<span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>local_n <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>glm<span class="op">::</span>mat3<span class="op">(</span>tangent<span class="op">,</span> bitangent<span class="op">,</span> local_n<span class="op">)</span> <span class="op">*</span> glm<span class="op">::</span>normalize<span class="op">(</span>sample<span class="op">));</span></span></code></pre></div>
<p>The <code>GET_CORRECT_POS</code> macro chooses the correct coordinate depending on the texture type, images using UV and noise and checkerboard using world coordinates. I needed to change the range of the sample from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,1)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>−</mi><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[-1,1)</annotation></semantics></math>. At first, I did not, and the result was this:</p>
<figure>
<img src="./assets/cube_waves_(0%201)%20instead%20of%20(-1%201).png" alt="Cube with Waves with Sample Range [0,1)" />
<figcaption aria-hidden="true">Cube with Waves with Sample Range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,1)</annotation></semantics></math></figcaption>
</figure>
<p>When I fixed that, with the code above, I got the correct result:</p>
<figure>
<img src="./assets/cube_waves.png" alt="Correct Cube with Waves" />
<figcaption aria-hidden="true">Correct Cube with Waves</figcaption>
</figure>
<p>This is also pretty much pixel perfect.</p>
<p>After this, I tested all cases with normal maps. And oh boy, the results were breath-taking:</p>
<figure>
<img src="./assets/brickwall_with_normalmap.png" alt="Brickwall with Normalmap" />
<figcaption aria-hidden="true">Brickwall with Normalmap</figcaption>
</figure>
<figure>
<img src="./assets/cube_cushion.png" alt="Cube with Cushion Texture" />
<figcaption aria-hidden="true">Cube with Cushion Texture</figcaption>
</figure>
<figure>
<img src="./assets/cube_wall_normal.png" alt="Cube Wall with Normalmap" />
<figcaption aria-hidden="true">Cube Wall with Normalmap</figcaption>
</figure>
<figure>
<img src="./assets/sphere_normal.png" alt="Sphere with Earth Normalmap" />
<figcaption aria-hidden="true">Sphere with Earth Normalmap</figcaption>
</figure>
<p>Well, let’s do the last part, the bump mapping! The problem is, bump mapping is a bit harder. The formula for bump mapping is as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mtext mathvariant="bold">𝐪</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>u</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mtext mathvariant="bold">𝐩</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>u</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>d</mi><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mtext mathvariant="bold">𝐧</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\frac{d\textbf{q}(u,v)}{du} = \frac{d\textbf{p}(u,v)}{du} + \frac{dh(u,v)}{dy}\textbf{n}(u,v)
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mtext mathvariant="bold">𝐪</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>v</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mtext mathvariant="bold">𝐩</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>v</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>d</mi><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><mtext mathvariant="bold">𝐧</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\frac{d\textbf{q}(u,v)}{dv} = \frac{d\textbf{p}(u,v)}{dv} + \frac{dh(u,v)}{dy}\textbf{n}(u,v)
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant="bold">𝐧</mtext><mo>′</mo></msup><mo>=</mo><mfrac><mrow><mi>d</mi><mtext mathvariant="bold">𝐪</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>u</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>d</mi><mtext mathvariant="bold">𝐪</mtext><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>d</mi><mi>v</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\textbf{n}&#39; = \frac{d\textbf{q}(u,v)}{du} \times \frac{d\textbf{q}(u,v)}{dv}
</annotation></semantics></math></p>
<p>I implemented this formula as this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> d <span class="op">=</span> textures<span class="op">-&gt;</span>bump<span class="op">-&gt;</span>get_derivative<span class="op">();</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> du <span class="op">=</span> d<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dv <span class="op">=</span> d<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> factor <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">/</span> <span class="fl">3.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> sample_pos <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span>uv<span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> u_sample_pos <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span>sample_pos <span class="op">+</span> glm<span class="op">::</span>vec3<span class="op">(</span>du<span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> v_sample_pos <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span>sample_pos <span class="op">+</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> dv<span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> sample <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>textures<span class="op">-&gt;</span>bump<span class="op">-&gt;</span>sample<span class="op">(</span>sample_pos<span class="op">),</span> factor<span class="op">);</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> u_sample <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>textures<span class="op">-&gt;</span>bump<span class="op">-&gt;</span>sample<span class="op">(</span>u_sample_pos<span class="op">),</span> factor<span class="op">);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> v_sample <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>textures<span class="op">-&gt;</span>bump<span class="op">-&gt;</span>sample<span class="op">(</span>v_sample_pos<span class="op">),</span> factor<span class="op">);</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dh_du <span class="op">=</span> <span class="op">(</span>u_sample <span class="op">-</span> sample<span class="op">)</span> <span class="op">*</span> bump_factor<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dh_dv <span class="op">=</span> <span class="op">(</span>v_sample <span class="op">-</span> sample<span class="op">)</span> <span class="op">*</span> bump_factor<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dq_du <span class="op">=</span> tangent <span class="op">+</span> dh_du <span class="op">*</span> local_n<span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dq_dv <span class="op">=</span> bitangent <span class="op">+</span> dh_dv <span class="op">*</span> local_n<span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> new_n <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>glm<span class="op">::</span>cross<span class="op">(</span>dq_dv<span class="op">,</span> dq_du<span class="op">));</span></span></code></pre></div>
<p>Since we are using <del>finite state machines</del> computers with finite memory, precision and processing power, we need to do a numerical derivative with a reasonably small difference. The lecture slides recommended <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mi>w</mi></mfrac><annotation encoding="application/x-tex">\frac{1}{w}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mi>h</mi></mfrac><annotation encoding="application/x-tex">\frac{1}{h}</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">du</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">dv</annotation></semantics></math>, respectively, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> is the width of the image and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> is the height of it. The <code>get_derivative</code> virtual function is for this. However, for a correct derivative, we need to divide the difference between the samples by <code>du</code> and <code>dv</code>, which, as you can see, is not in the code. However, since <code>du</code> and <code>dv</code> become smaller and smaller as the image resolution increases while the difference between samples cannot be in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mfrac><mn>1</mn><mrow><mn>3</mn><mo>*</mo><mn>255</mn></mrow></mfrac><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0, \frac{1}{3*255})</annotation></semantics></math> due to the images having 3 8-bit channels, resolution increase results in bigger <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>d</mi><mi>h</mi></mrow><mrow><mi>d</mi><mi>u</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{dh}{du}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>d</mi><mi>h</mi></mrow><mrow><mi>d</mi><mi>v</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{dh}{dv}</annotation></semantics></math>. This resulted in pretty interesting images like this:</p>
<figure>
<img src="./assets/bump_mapping_transformed_derivative_division.png" alt="Bump Mapping Transformed with Derivative Division" />
<figcaption aria-hidden="true">Bump Mapping Transformed with Derivative Division</figcaption>
</figure>
<p>Even a small bit of change in the bump map image luminance bends the normals sharply. Unfortunately, fixing this was not sufficient:</p>
<figure>
<img src="./assets/bump_mapping_transformed_wrong_sphere_bitangent.png" alt="Bump Mapping Transformed without Derivative Division but with Wrong Sphere Bitangent" />
<figcaption aria-hidden="true">Bump Mapping Transformed without Derivative Division but with Wrong Sphere Bitangent</figcaption>
</figure>
<p>The image is much better, but the sphere is a bit weird. After some inspection and painful debugging sessions, I found out that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐁</mtext><mo>×</mo><mtext mathvariant="bold">𝐓</mtext></mrow><annotation encoding="application/x-tex">\textbf{B} \times \textbf{T}</annotation></semantics></math> was not equal to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐧</mtext><annotation encoding="application/x-tex">\textbf{n}</annotation></semantics></math> for spheres. This was pretty interesting, and the reason (after almost 1 day of debugging) was that I used the local coordinate of the hit point in bitangent calculation instead of the local coordinate of the hit point <em>minus the center of the sphere</em>. When I fixed it, the result became this:</p>
<figure>
<img src="./assets/bump_mapping_transformed_semi_correct.png" alt="Bump Mapping Transformed with Some Error" />
<figcaption aria-hidden="true">Bump Mapping Transformed with Some Error</figcaption>
</figure>
<p>The result is not exactly the same as the reference image, where the bumps are much more pronounced. However, I have not managed to fix this issue and honestly, I do not know how to do it.</p>
<p>The last thing I did was fixing the parser so that I could render Veach Ajar. The result was pretty nice, but it had an error:</p>
<figure>
<img src="./assets/VeachAjar_modulo.png" alt="Veach Ajar with Weird Floor" />
<figcaption aria-hidden="true">Veach Ajar with Weird Floor</figcaption>
</figure>
<p>After doing another debugging session, I managed to learn the reason of the error in the floor. The error was actually something I did before: modulo with negative result. Since I had the macro and the right hand side of the modulo is again a power of 2 (2 to be exact), I used the same macro to do mathematically correct modulus. The result was pretty good:</p>
<figure>
<img src="./assets/VeachAjar.png" alt="Mostly Correct Veach Ajar" />
<figcaption aria-hidden="true">Mostly Correct Veach Ajar</figcaption>
</figure>
<p>I think the result looks pretty much correct at first glance. However, there are a few issues like the checkerboard pattern being a bit stretched out, the second teapot (in the middle) having a darker reflection of the table and a difference on the left side of the door that I cannot explain. In both images (mine and reference), the same part of the door texture becomes different compared to the remaining parts of the door, but the difference itself is different between the images. Here is the reference Veach Ajar for comparison:</p>
<figure>
<img src="./assets/VeachAjar_reference.png" alt="Reference Veach Ajar" />
<figcaption aria-hidden="true">Reference Veach Ajar</figcaption>
</figure>
<p>The last thing I did was Galactica and background texture. This was pretty easy, so I will not delve into the implementation details here. However, the result was another interesting one:</p>
<figure>
<img src="./assets/galactica_static_inverse_normals.png" alt="Galactica Static but Half" />
<figcaption aria-hidden="true">Galactica Static but Half</figcaption>
</figure>
<p>The right side of the spaceship is black! After the last debugging session, I found out that the normals on the right side of the spaceship are the inverse of the correct normals after bump mapping! Well, the bump mapping does not affect the new normal that much in this image, so I tested the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐁</mtext><mo>×</mo><mtext mathvariant="bold">𝐓</mtext></mrow><annotation encoding="application/x-tex">\textbf{B} \times \textbf{T}</annotation></semantics></math> in my calculator and found out that <em>they</em> were the culprit. I fixed this by multiplying the tangent by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math> in the tangent and bitangent pre-calculation part if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐁</mtext><mo>×</mo><mtext mathvariant="bold">𝐓</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mtext mathvariant="bold">𝐧</mtext></mrow><annotation encoding="application/x-tex">\left(\textbf{B} \times \textbf{T}\right) \cdot \textbf{n}</annotation></semantics></math> is negative (which means that the calculated normal and real normal are in opposite directions). When I fixed this, the image became pretty much the same as the reference one:</p>
<figure>
<img src="./assets/galactica_static_correct.png" alt="Mostly Correct Galactica Static" />
<figcaption aria-hidden="true">Mostly Correct Galactica Static</figcaption>
</figure>
<p>I guess the difference between my image and reference image is caused by the same reason behind the difference in bump mapping transformed.</p>
<p>Bump mapping without texture coordinates was actually much easier than my expectation. It also worked well, unlike image bump mapping. The whole implementation after <code>get_gradient</code> method I showed earlier is this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> g <span class="op">=</span> textures<span class="op">-&gt;</span>bump<span class="op">-&gt;</span>get_gradient<span class="op">(</span>hit_point<span class="op">,</span> bump_factor<span class="op">);</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="va">g_parallel</span> <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>g<span class="op">,</span> local_n<span class="op">)</span> <span class="op">*</span> local_n<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="va">g_perpendicular</span> <span class="op">=</span> g <span class="op">-</span> <span class="va">g_parallel</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>local_n <span class="op">=</span> glm<span class="op">::</span>normalize<span class="op">(</span>local_n <span class="op">-</span> <span class="va">g_perpendicular</span><span class="op">);</span></span></code></pre></div>
<p>At the end, I tried to implement trilinear sampling. However, it is pretty difficult to do since it needs camera offsets on top of UV coordinates, which is pretty difficult to get in ray tracing. In the lectures, we discussed about trilinear sampling in ray tracing using ray differentials, which is also the approach taken in the PBR book. I more-or-less implemented it; however, the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> results in negative values, which means that -after clamping- the mipmaps are not used at all. I would like to solve this problem, if I can. My current implementation is as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> d <span class="op">=</span> <span class="op">-</span>glm<span class="op">::</span>dot<span class="op">(</span>world_n<span class="op">,</span> hit_point<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> tx <span class="op">=</span> <span class="op">(-</span>glm<span class="op">::</span>dot<span class="op">(</span>world_n<span class="op">,</span> r<span class="op">.</span>right_origin<span class="op">)</span> <span class="op">-</span> d<span class="op">)</span> <span class="op">/</span> glm<span class="op">::</span>dot<span class="op">(</span>world_n<span class="op">,</span> r<span class="op">.</span>right_direction<span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> px <span class="op">=</span> r<span class="op">.</span>right_origin <span class="op">+</span> tx <span class="op">*</span> r<span class="op">.</span>right_direction<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ty <span class="op">=</span> <span class="op">(-</span>glm<span class="op">::</span>dot<span class="op">(</span>world_n<span class="op">,</span> r<span class="op">.</span>down_origin<span class="op">)</span> <span class="op">-</span> d<span class="op">)</span> <span class="op">/</span> glm<span class="op">::</span>dot<span class="op">(</span>world_n<span class="op">,</span> r<span class="op">.</span>down_direction<span class="op">);</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> py <span class="op">=</span> r<span class="op">.</span>down_origin <span class="op">+</span> ty <span class="op">*</span> r<span class="op">.</span>down_direction<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dpdx <span class="op">=</span> px <span class="op">-</span> hit_point<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dpdy <span class="op">=</span> py <span class="op">-</span> hit_point<span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dpdu <span class="op">=</span> tangent<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dpdv <span class="op">=</span> bitangent<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ata00 <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdu<span class="op">,</span> dpdu<span class="op">);</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ata01 <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdu<span class="op">,</span> dpdv<span class="op">);</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ata11 <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdv<span class="op">,</span> dpdv<span class="op">);</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="va">inv_det_</span> <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span> <span class="op">/</span> difference_of_products<span class="op">(</span>ata00<span class="op">,</span> ata11<span class="op">,</span> ata01<span class="op">,</span> ata01<span class="op">);</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> inv_det <span class="op">=</span> is_finite<span class="op">(</span><span class="va">inv_det_</span><span class="op">)</span> <span class="op">?</span> <span class="va">inv_det_</span> <span class="op">:</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> atb0x <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdu<span class="op">,</span> dpdx<span class="op">);</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> atb1x <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdv<span class="op">,</span> dpdx<span class="op">);</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> atb0y <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdu<span class="op">,</span> dpdy<span class="op">);</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> atb1y <span class="op">=</span> glm<span class="op">::</span>dot<span class="op">(</span>dpdv<span class="op">,</span> dpdy<span class="op">);</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> dudx <span class="op">=</span> difference_of_products<span class="op">(</span>ata11<span class="op">,</span> atb0x<span class="op">,</span> ata01<span class="op">,</span> atb1x<span class="op">)</span> <span class="op">*</span> inv_det<span class="op">;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> dvdx <span class="op">=</span> difference_of_products<span class="op">(</span>ata00<span class="op">,</span> atb1x<span class="op">,</span> ata01<span class="op">,</span> atb0x<span class="op">)</span> <span class="op">*</span> inv_det<span class="op">;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> dudy <span class="op">=</span> difference_of_products<span class="op">(</span>ata11<span class="op">,</span> atb0y<span class="op">,</span> ata01<span class="op">,</span> atb1y<span class="op">)</span> <span class="op">*</span> inv_det<span class="op">;</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> dvdy <span class="op">=</span> difference_of_products<span class="op">(</span>ata00<span class="op">,</span> atb1y<span class="op">,</span> ata01<span class="op">,</span> atb0y<span class="op">)</span> <span class="op">*</span> inv_det<span class="op">;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>dudx <span class="op">=</span> is_finite<span class="op">(</span>dudx<span class="op">)</span> <span class="op">?</span> clamp<span class="op">(</span>dudx<span class="op">,</span> <span class="op">-</span><span class="fl">1e8</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1e8</span><span class="bu">f</span><span class="op">)</span> <span class="op">:</span> <span class="fl">0.</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>dvdx <span class="op">=</span> is_finite<span class="op">(</span>dvdx<span class="op">)</span> <span class="op">?</span> clamp<span class="op">(</span>dvdx<span class="op">,</span> <span class="op">-</span><span class="fl">1e8</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1e8</span><span class="bu">f</span><span class="op">)</span> <span class="op">:</span> <span class="fl">0.</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>dudy <span class="op">=</span> is_finite<span class="op">(</span>dudy<span class="op">)</span> <span class="op">?</span> clamp<span class="op">(</span>dudy<span class="op">,</span> <span class="op">-</span><span class="fl">1e8</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1e8</span><span class="bu">f</span><span class="op">)</span> <span class="op">:</span> <span class="fl">0.</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>dvdy <span class="op">=</span> is_finite<span class="op">(</span>dvdy<span class="op">)</span> <span class="op">?</span> clamp<span class="op">(</span>dvdy<span class="op">,</span> <span class="op">-</span><span class="fl">1e8</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1e8</span><span class="bu">f</span><span class="op">)</span> <span class="op">:</span> <span class="fl">0.</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dx_vtc <span class="op">=</span> glm<span class="op">::</span>vec2<span class="op">(</span>dudx<span class="op">,</span> dvdx<span class="op">);</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> dy_vtc <span class="op">=</span> glm<span class="op">::</span>vec2<span class="op">(</span>dudy<span class="op">,</span> dvdy<span class="op">);</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> delta_max_sqr <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>glm<span class="op">::</span>dot<span class="op">(</span>dx_vtc<span class="op">,</span> dx_vtc<span class="op">),</span> glm<span class="op">::</span>dot<span class="op">(</span>dy_vtc<span class="op">,</span> dy_vtc<span class="op">));</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>hi<span class="op">.</span>lambda <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">std::</span>log2<span class="op">(</span>delta_max_sqr<span class="op">);</span></span></code></pre></div>
<p>Until <code>dx_vtc</code>’s definition, the code is pretty much the same as in the PBR book, but it does not work for some reason.</p>
<h1 id="results">Results</h1>
<p>Most of the cases I have shown so far have been a great deal of the test cases of the homework. Here are the remaining ones:</p>
<figure>
<img src="./assets/ellipsoids_texture_correct.png" alt="Ellipsoids with Texture" />
<figcaption aria-hidden="true">Ellipsoids with Texture</figcaption>
</figure>
<figure>
<img src="./assets/cube_perlin_bump.png" alt="Cubes with Bump Based on Noise" />
<figcaption aria-hidden="true">Cubes with Bump Based on Noise</figcaption>
</figure>
<figure>
<img src="./assets/galactica_dynamic.png" alt="In a Galaxy Far Far Away" />
<figcaption aria-hidden="true"><a href="https://www.youtube.com/watch?v=5EWEkJA5GM0">In a Galaxy Far Far Away</a></figcaption>
</figure>
<figure>
<img src="./assets/killeroo_bump_walls.png" alt="Killeroo on an RGB Bumped Space" />
<figcaption aria-hidden="true">Killeroo on an RGB Bumped Space</figcaption>
</figure>
<figure>
<img src="./assets/meme.jpg" alt="Someone else on an RGB Bumped Space" />
<figcaption aria-hidden="true">Someone else on an RGB Bumped Space</figcaption>
</figure>
<figure>
<img src="./assets/sphere_nearest_bilinear.png" alt="Spheres with Nearest Neighbor and Bilinear Sampling" />
<figcaption aria-hidden="true">Spheres with Nearest Neighbor and Bilinear Sampling</figcaption>
</figure>
<figure>
<img src="./assets/sphere_nobump_bump.png" alt="Earths without Bump and with Bump Mapping" />
<figcaption aria-hidden="true">Earths without Bump and with Bump Mapping</figcaption>
</figure>
<figure>
<img src="./assets/sphere_nobump_justbump.png" alt="Earths without Bump and only with Bump Mapping" />
<figcaption aria-hidden="true">Earths without Bump and only with Bump Mapping</figcaption>
</figure>
<figure>
<img src="./assets/sphere_perlin_bump.png" alt="Spheres with Bump Mapping Based on Noise" />
<figcaption aria-hidden="true">Spheres with Bump Mapping Based on Noise</figcaption>
</figure>
<figure>
<img src="./assets/mytap_final.png" alt="Failed Tap" />
<figcaption aria-hidden="true">Failed Tap</figcaption>
</figure>
<p>The scene looks much brighter than it should. I did not have enough time to inspect this problem. However, I guess the most problematic scene in this homework was this.</p>
<figure>
<img src="./assets/dragon_new.png" alt="Dragon with Noise" />
<figcaption aria-hidden="true">Dragon with Noise</figcaption>
</figure>
<p>My dragon looks somewhat darker than the reference image. However, I don’t think there is a problem in the implementation, debugging yielded the correct shading calculations. I think the difference between seeds is the reason of the difference.</p>
<h1 id="performance">Performance</h1>
<h2 id="compiler-benchmark">Compiler Benchmark</h2>
<p>All tests are done on the same computer (my computer, with the processor AMD Ryzen 7735HS) with both executables compiled with CMake’s Release mode. This passes <code>-O3</code> to GCC and <code>/O2</code> to MSVC (both of which are the maximum possible optimization level for their respective compilers).</p>
<p>This is the comparison for single threaded performance. MSVC took 52.46% of time of GCC for initialization and 149.81% of time of GCC for rendering. Since rendering time dominated the total time, the ratio of total times is similar to the ratio of render times with MSVC taking 149.39% of time of GCC.</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 16%" />
<col style="width: 17%" />
<col style="width: 18%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr>
<th>Testcase</th>
<th>Init Time (GCC)</th>
<th>Init Time (MSVC)</th>
<th>Render Time (GCC)</th>
<th>Render Time (MSVC)</th>
</tr>
</thead>
<tbody>
<tr>
<td>simple.xml</td>
<td>0.000738117</td>
<td>0.000329238</td>
<td>0.165579</td>
<td>0.296524</td>
</tr>
<tr>
<td>two_spheres.xml</td>
<td>0.000684635</td>
<td>0.000298101</td>
<td>0.14317</td>
<td>0.198186</td>
</tr>
<tr>
<td>instance/ellipsoids.xml</td>
<td>0.00118608</td>
<td>0.000405583</td>
<td>0.629211</td>
<td>0.929079</td>
</tr>
<tr>
<td>instance/spheres.xml</td>
<td>0.000853679</td>
<td>0.000357677</td>
<td>0.443273</td>
<td>0.676024</td>
</tr>
<tr>
<td>texture/sphere_perlin.xml</td>
<td>0.000778413</td>
<td>0.000330491</td>
<td>0.799263</td>
<td>0.695065</td>
</tr>
<tr>
<td>texture/wood_box.xml</td>
<td>0.0137741</td>
<td>0.0152521</td>
<td>0.662815</td>
<td>1.24051</td>
</tr>
<tr>
<td>texture/cube_cushion.xml</td>
<td>0.0109649</td>
<td>0.00916525</td>
<td>0.65897</td>
<td>1.22823</td>
</tr>
</tbody>
</table>
<figure>
<img src="./assets/plot_gcc_msvc_st.png" alt="GCC vs MSVC (Single Threaded)" />
<figcaption aria-hidden="true">GCC vs MSVC (Single Threaded)</figcaption>
</figure>
<figure>
<img src="./assets/plot_gcc_msvc_st_stacked.png" alt="GCC vs MSVC (Single Threaded, Stacked Plot)" />
<figcaption aria-hidden="true">GCC vs MSVC (Single Threaded, Stacked Plot)</figcaption>
</figure>
<p>For multithreaded, I could do more cases. The performance difference is pretty similar in initialization with MSVC taking 58.12% of time of GCC while rendering with MSVC taking 187.58% of GCC. Except for a few cases like Other Dragon (where MSVC init time was also higher), almost all cases are dominated by rendering time; hence, the overall difference is pretty similar to rendering differences like in single threaded case. The render time gap is widened in multithreading, which I think is due to the fact that OpenMP version is older in MSVC.</p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 17%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>Testcase</th>
<th>Init Time (GCC)</th>
<th>Init Time (MSVC)</th>
<th>Render Time (GCC)</th>
<th>Render Time (MSVC)</th>
</tr>
</thead>
<tbody>
<tr>
<td>bunny.xml</td>
<td>0.0259272</td>
<td>0.0137872</td>
<td>0.0252325</td>
<td>0.0422266</td>
</tr>
<tr>
<td>cornellbox_recursive.xml</td>
<td>0.000824259</td>
<td>0.000408424</td>
<td>0.161469</td>
<td>0.338575</td>
</tr>
<tr>
<td>other_dragon.xml</td>
<td>1.90039</td>
<td>3.12535</td>
<td>0.325022</td>
<td>0.492461</td>
</tr>
<tr>
<td>scienceTree_glass.xml</td>
<td>0.0120762</td>
<td>0.00569955</td>
<td>0.428713</td>
<td>0.804977</td>
</tr>
<tr>
<td>simple.xml</td>
<td>0.00057505</td>
<td>0.000328117</td>
<td>0.0189683</td>
<td>0.035272</td>
</tr>
<tr>
<td>two_spheres.xml</td>
<td>0.000516159</td>
<td>0.000309414</td>
<td>0.0140184</td>
<td>0.023998</td>
</tr>
<tr>
<td>instance/ellipsoids.xml</td>
<td>0.000937798</td>
<td>0.000409021</td>
<td>0.0525233</td>
<td>0.111615</td>
</tr>
<tr>
<td>instance/metal_glass_plates.xml</td>
<td>0.000948858</td>
<td>0.000450717</td>
<td>0.546101</td>
<td>1.08937</td>
</tr>
<tr>
<td>instance/spheres.xml</td>
<td>0.000665289</td>
<td>0.000358539</td>
<td>0.0419996</td>
<td>0.0840711</td>
</tr>
<tr>
<td>dist/cornellbox_area.xml</td>
<td>0.00105392</td>
<td>0.000420615</td>
<td>6.8415</td>
<td>14.0883</td>
</tr>
<tr>
<td>dist/focusing_dragons.xml</td>
<td>0.750828</td>
<td>1.12671</td>
<td>42.3022</td>
<td>79.6751</td>
</tr>
<tr>
<td>dist/metal_glass_plates.xml</td>
<td>0.0013245</td>
<td>0.000455512</td>
<td>16.7168</td>
<td>29.4731</td>
</tr>
<tr>
<td>dist/spheres_dof.xml</td>
<td>0.000672332</td>
<td>0.000361171</td>
<td>3.86022</td>
<td>7.4544</td>
</tr>
</tbody>
</table>
<figure>
<img src="./assets/plot_gcc_msvc_mt.png" alt="GCC vs MSVC (Multi Threaded)" />
<figcaption aria-hidden="true">GCC vs MSVC (Multi Threaded)</figcaption>
</figure>
<figure>
<img src="./assets/plot_gcc_msvc_mt_stacked.png" alt="GCC vs MSVC (Multi Threaded, Stacked Plot)" />
<figcaption aria-hidden="true">GCC vs MSVC (Multi Threaded, Stacked Plot)</figcaption>
</figure>
<p>Since Focusing Dragons breaks the scale of the graph, here is the plot without that case:</p>
<figure>
<img src="./assets/plot_gcc_msvc_mt_focusing.png" alt="GCC vs MSVC (Multi Threaded, No Focusing Dragons)" />
<figcaption aria-hidden="true">GCC vs MSVC (Multi Threaded, No Focusing Dragons)</figcaption>
</figure>
<figure>
<img src="./assets/plot_gcc_msvc_mt_focusing_stacked.png" alt="GCC vs MSVC (Multi Threaded, No Focusing Dragons, Stacked Plot)" />
<figcaption aria-hidden="true">GCC vs MSVC (Multi Threaded, No Focusing Dragons, Stacked Plot)</figcaption>
</figure>
<h2 id="texture-benchmark">Texture Benchmark</h2>
<p>And here is the big benchmark! MSVC took 72.2% of the time of GCC to initialize while taking 157.4% of the time of GCC to render scenes. As usual, render time dominates the total time, so the result was that MSVC took 150.7% of the time of GCC to start and finish the whole job.</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 14%" />
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>Testcase</th>
<th>Init Time (GCC)</th>
<th>Init Time (MSVC)</th>
<th>Render Time (GCC)</th>
<th>Render Time (MSVC)</th>
</tr>
</thead>
<tbody>
<tr>
<td>bunny.xml</td>
<td>0.0263316</td>
<td>0.0136175</td>
<td>0.0287202</td>
<td>0.0468452</td>
</tr>
<tr>
<td>cornellbox_recursive.xml</td>
<td>0.00104192</td>
<td>0.000428546</td>
<td>0.238443</td>
<td>0.371436</td>
</tr>
<tr>
<td>other_dragon.xml</td>
<td>2.00303</td>
<td>3.22427</td>
<td>0.361571</td>
<td>0.525055</td>
</tr>
<tr>
<td>scienceTree_glass.xml</td>
<td>0.0132723</td>
<td>0.0058431</td>
<td>0.478199</td>
<td>0.870111</td>
</tr>
<tr>
<td>simple.xml</td>
<td>0.000747665</td>
<td>0.000364378</td>
<td>0.0220329</td>
<td>0.0400985</td>
</tr>
<tr>
<td>two_spheres.xml</td>
<td>0.000703956</td>
<td>0.00033162</td>
<td>0.0223661</td>
<td>0.0281506</td>
</tr>
<tr>
<td>instance/ellipsoids.xml</td>
<td>0.00115964</td>
<td>0.000440787</td>
<td>0.0824988</td>
<td>0.122891</td>
</tr>
<tr>
<td>instance/ellipsoids.xml</td>
<td>0.000908217</td>
<td>0.000434246</td>
<td>0.081917</td>
<td>0.122259</td>
</tr>
<tr>
<td>instance/metal_glass_plates.xml</td>
<td>0.00118432</td>
<td>0.000474137</td>
<td>0.677238</td>
<td>1.15823</td>
</tr>
<tr>
<td>instance/spheres.xml</td>
<td>0.000847961</td>
<td>0.000384326</td>
<td>0.0594592</td>
<td>0.094961</td>
</tr>
<tr>
<td>dist/cornellbox_area.xml</td>
<td>0.00102876</td>
<td>0.000429739</td>
<td>9.2073</td>
<td>15.0258</td>
</tr>
<tr>
<td>dist/focusing_dragons.xml</td>
<td>0.798259</td>
<td>1.17336</td>
<td>33.8644</td>
<td>58.6734</td>
</tr>
<tr>
<td>dist/metal_glass_plates.xml</td>
<td>0.00130076</td>
<td>0.000488106</td>
<td>19.3926</td>
<td>31.6583</td>
</tr>
<tr>
<td>dist/spheres_dof.xml</td>
<td>0.000941244</td>
<td>0.00038669</td>
<td>5.78713</td>
<td>8.19425</td>
</tr>
<tr>
<td>texture/bump_mapping_transformed.xml</td>
<td>0.0748437</td>
<td>0.0851226</td>
<td>0.131904</td>
<td>0.148202</td>
</tr>
<tr>
<td>texture/brickwall_with_normalmap.xml</td>
<td>0.0211646</td>
<td>0.0224583</td>
<td>0.0862123</td>
<td>0.165274</td>
</tr>
<tr>
<td>texture/cube_cushion.xml</td>
<td>0.0112663</td>
<td>0.00927417</td>
<td>0.0838197</td>
<td>0.16078</td>
</tr>
<tr>
<td>texture/cube_perlin.xml</td>
<td>0.00131063</td>
<td>0.000526643</td>
<td>0.124521</td>
<td>0.272554</td>
</tr>
<tr>
<td>texture/cube_perlin_bump.xml</td>
<td>0.00133815</td>
<td>0.000540437</td>
<td>0.137821</td>
<td>0.294797</td>
</tr>
<tr>
<td>texture/cube_wall.xml</td>
<td>0.00995929</td>
<td>0.0110708</td>
<td>0.0790112</td>
<td>0.156742</td>
</tr>
<tr>
<td>texture/cube_wall_normal.xml</td>
<td>0.0178733</td>
<td>0.0207233</td>
<td>0.0866704</td>
<td>0.163564</td>
</tr>
<tr>
<td>texture/cube_waves.xml</td>
<td>0.00784749</td>
<td>0.00841713</td>
<td>0.0843926</td>
<td>0.162292</td>
</tr>
<tr>
<td>texture/ellipsoids_texture.xml</td>
<td>0.0179725</td>
<td>0.0208412</td>
<td>0.0793805</td>
<td>0.118619</td>
</tr>
<tr>
<td>texture/galactica_dynamic.xml</td>
<td>0.0648881</td>
<td>0.0352906</td>
<td>36.8541</td>
<td>70.4954</td>
</tr>
<tr>
<td>texture/galactica_static.xml</td>
<td>0.0650413</td>
<td>0.0355861</td>
<td>0.376033</td>
<td>0.738424</td>
</tr>
<tr>
<td>texture/killeroo_bump_walls.xml</td>
<td>0.488267</td>
<td>0.2826</td>
<td>0.270957</td>
<td>0.466517</td>
</tr>
<tr>
<td>texture/plane_bilinear.xml</td>
<td>0.0183216</td>
<td>0.0203739</td>
<td>0.0278078</td>
<td>0.0332584</td>
</tr>
<tr>
<td>texture/sphere_nearest_bilinear.xml</td>
<td>0.0191072</td>
<td>0.0204062</td>
<td>0.0894229</td>
<td>0.0906545</td>
</tr>
<tr>
<td>texture/sphere_nobump_bump.xml</td>
<td>0.00758596</td>
<td>0.00873892</td>
<td>0.0956179</td>
<td>0.101027</td>
</tr>
<tr>
<td>texture/sphere_nobump_justbump.xml</td>
<td>0.00756381</td>
<td>0.00877101</td>
<td>0.0929962</td>
<td>0.0978418</td>
</tr>
<tr>
<td>texture/sphere_perlin.xml</td>
<td>0.000815369</td>
<td>0.000360108</td>
<td>0.14301</td>
<td>0.144179</td>
</tr>
<tr>
<td>texture/sphere_perlin_bump.xml</td>
<td>0.000838961</td>
<td>0.000359113</td>
<td>0.160708</td>
<td>0.165377</td>
</tr>
<tr>
<td>texture/sphere_perlin_scale.xml</td>
<td>0.000605388</td>
<td>0.000352115</td>
<td>0.143759</td>
<td>0.145046</td>
</tr>
<tr>
<td>texture/wood_box.xml</td>
<td>0.0141614</td>
<td>0.0155433</td>
<td>0.0816696</td>
<td>0.158564</td>
</tr>
<tr>
<td>texture/wood_box_all.xml</td>
<td>0.0130072</td>
<td>0.0156655</td>
<td>0.0971621</td>
<td>0.175384</td>
</tr>
<tr>
<td>texture/wood_box_no_specular.xml</td>
<td>0.00962229</td>
<td>0.0103033</td>
<td>0.0813137</td>
<td>0.156096</td>
</tr>
<tr>
<td>texture/veach_ajar/scene.xml</td>
<td>0.438321</td>
<td>0.385892</td>
<td>54.9581</td>
<td>106.965</td>
</tr>
<tr>
<td>texture/dragon/dragon_new_ply.xml</td>
<td>0.39476</td>
<td>0.601212</td>
<td>2.449</td>
<td>4.68368</td>
</tr>
<tr>
<td>texture/mytap/mytap_final.xml</td>
<td>0.0444798</td>
<td>0.0562646</td>
<td>22.8472</td>
<td>36.0329</td>
</tr>
</tbody>
</table>
<figure>
<img src="./assets/plot.png" alt="GCC vs MSVC" />
<figcaption aria-hidden="true">GCC vs MSVC</figcaption>
</figure>
<figure>
<img src="./assets/plot_stacked.png" alt="GCC vs MSVC (Stacked Plot)" />
<figcaption aria-hidden="true">GCC vs MSVC (Stacked Plot)</figcaption>
</figure>
<p>To make the scale less broken, here is the plot without Focusing Dragons, Metal Glass Plates (Dist), Galactica Dynamic, Veach Ajar and Tap (Texture):</p>
<figure>
<img src="./assets/plot_smaller.png" alt="GCC vs MSVC (Some Cases Omitted)" />
<figcaption aria-hidden="true">GCC vs MSVC (Some Cases Omitted)</figcaption>
</figure>
<figure>
<img src="./assets/plot_smaller_stacked.png" alt="GCC vs MSVC (Some Cases Omitted, Stacked Plot)" />
<figcaption aria-hidden="true">GCC vs MSVC (Some Cases Omitted, Stacked Plot)</figcaption>
</figure>
<h1 id="conclusion">Conclusion</h1>
<p>As we get closer to the end of the semester, our outputs have been becoming better with each homework. Texture support is pretty much a must for any serious rendering engine, and the results show breathtaking images with the addition of this ancient technique. Unfortunately, this time, I have not learnt a life lesson from the homework, but I think learning 3 of such lessons from this series of homeworks has been a miracle in itself. Those homeworks still addict the student tho. I find myself to work on this instead of the term project, while my grades for the term project have been abysmal compared to the 795 homeworks. It is also sad that I have not been able to implement trilinear mapping properly.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Oh, I have been waiting to do this reference since the end of that week! This is a reference to <a href="https://anilist.co/manga/100080/Oniichan-wa-Oshimai"><ruby>お<rp>(</rp><rt>O</rt><rp>)</rp></ruby><ruby>兄<rp>(</rp><rt>nii</rt><rp>)</rp></ruby><ruby>ち<rp>(</rp><rt>ch</rt><rp>)</rp></ruby><ruby>ゃ<rp>(</rp><rt>a</rt><rp>)</rp></ruby></ruby><ruby>ん<rp>(</rp><rt>n</rt><rp>)</rp></ruby> <ruby>は<rp>(</rp><rt>wa</rt><rp>)</rp></ruby> <ruby>お<rp>(</rp><rt>o</rt><rp>)</rp></ruby><ruby>し<rp>(</rp><rt>shi</rt><rp>)</rp></ruby><ruby>ま<rp>(</rp><rt>ma</rt><rp>)</rp></ruby><ruby>い<rp>(</rp><rt>i</rt><rp>)</rp></ruby>!</a> (read as written above the characters), a manga/anime whose name is usually translated as “Older Brother is Done For!” (the “<ruby>お<rp>(</rp><rt>o</rt><rp>)</rp></ruby><ruby>し<rp>(</rp><rt>shi</rt><rp>)</rp></ruby><ruby>ま<rp>(</rp><rt>ma</rt><rp>)</rp></ruby><ruby>い<rp>(</rp><rt>i</rt><rp>)</rp></ruby>” part is translated as “to be done for” but it actually has some sort of a hidden meaning due to how it is written, <ruby>お<rp>(</rp><rt>o</rt><rp>)</rp></ruby><ruby>し<rp>(</rp><rt>shi</rt><rp>)</rp></ruby><ruby>ま<rp>(</rp><rt>ma</rt><rp>)</rp></ruby><ruby>い<rp>(</rp><rt>i</rt><rp>)</rp></ruby> instead of <ruby>お<rp>(</rp><rt>o</rt><rp>)</rp></ruby><ruby>仕<rp>(</rp><rt>shi</rt><rp>)</rp></ruby><ruby>舞<rp>(</rp><rt>ma</rt><rp>)</rp></ruby><ruby>い<rp>(</rp><rt>i</rt><rp>)</rp></ruby>) and which is one of my favorites. The phrase “X is done for” is also used throughout different parts of the manga translation. The phrase itself is of course used generally in English, but the translation of the manga uses it so extensively that the phrase has somewhat become an inside joke of the fans.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
	</article>

	<div id="metadata">
		<div id="navigation">
			<h1>Site</h1>
			<ul>
				<li><a href="/about">Hakkımda</a></li>
				<li><a href="/gönderiler">Gönderiler</a></li>
				<li><a href="/etiketler">Etiketler</a></li>
			</ul>
		</div>

				<hr/>
		<div id="table-of-contents">
			<h1>İçindekiler</h1>
			<ul>
<li><a href="#reimplementation-failure" id="toc-reimplementation-failure">Reimplementation (Failure)</a></li>
<li><a href="#implementation" id="toc-implementation">Implementation</a>
<ul>
<li><a href="#diffuse-and-specular-textures" id="toc-diffuse-and-specular-textures">Diffuse and Specular Textures</a></li>
<li><a href="#noise-and-checkerboard" id="toc-noise-and-checkerboard">Noise and Checkerboard</a></li>
<li><a href="#normal-and-bump-mapping" id="toc-normal-and-bump-mapping">Normal and Bump Mapping</a></li>
</ul></li>
<li><a href="#results" id="toc-results">Results</a></li>
<li><a href="#performance" id="toc-performance">Performance</a>
<ul>
<li><a href="#compiler-benchmark" id="toc-compiler-benchmark">Compiler Benchmark</a></li>
<li><a href="#texture-benchmark" id="toc-texture-benchmark">Texture Benchmark</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul>
		</div>
		
				<hr/>
		<div id="time">
			<h1>Gönderilme Zamanı</h1>
			<ul>
				<li>
					<time><a href="/gönderiler/2024">2024</a>-<a href="/gönderiler/2024/12">12</a>-14 23:34:28+03:00</time>
				</li>
			</ul>
		</div>
		
				<hr/>
		<div id="tags">
			<h1>Etiketler</h1>
			<ul>
								<li><a href="/etiketler/C++">C++</a></li>
								<li><a href="/etiketler/Programlama">Programlama</a></li>
								<li><a href="/etiketler/Teknoloji">Teknoloji</a></li>
								<li><a href="/etiketler/Gönderi">Gönderi</a></li>
								<li><a href="/etiketler/Ödev">Ödev</a></li>
								<li><a href="/etiketler/Işın İzleme">Işın İzleme</a></li>
							</ul>
		</div>
		
	</div>

</div>

<footer>
	<div id="copyup">© Erencan Ceyhan, 2025</div>
	<div id="links">
		<a href="https://github.com/erenjanje">GitHub</a>
		<a href="https://www.linkedin.com/in/erencan-ceyhan/">LinkedIn</a>
		<a href="mailto:erencan.ceyhan@hotmail.com">E-Posta</a>
	</div>
</footer>
</body>
</html>