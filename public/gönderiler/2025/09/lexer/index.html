<!DOCTYPE html>
<html  lang="tr" >

<head>
	<meta charset="UTF-8" />
		<meta name="author" content="Erencan Ceyhan" />
			<meta name="keywords" content="Rust, Programlama, Teknoloji, Gönderi, Derleyiciler" />
		<title>Sıfırdan Derleyici 01: Lexer</title>
	<link href="/style/index.css" rel="stylesheet" />
</head>

<body>
	<img src="/consbar.gif"/>
	<h1 id="site-header">Lukantima</h1>
	<nav>
		<a href="/">Ana Sayfa</a>
		<a href="/about">Hakkımda</a>
		<a href="/gönderiler">Gönderiler</a>
		<a href="/etiketler">Etiketler</a>
	</nav>

	<article>
		<header>
		<h1 id="page-title">Sıfırdan Derleyici 01: Lexer</h1>
		</header>

				<ul>
<li><a href="#dilin-sözdizimi" id="toc-dilin-sözdizimi">Dilin Sözdizimi</a></li>
<li><a href="#tasarım" id="toc-tasarım">Tasarım</a></li>
<li><a href="#kod" id="toc-kod">Kod</a></li>
<li><a href="#sonuç" id="toc-sonuç">Sonuç</a></li>
</ul>
		<hr/>
		
		<p>Herkese merhabalar! YouTube’da tuhaf tuhaf oyun videoları çekmekten biraz sıkıldım ve karşınızda blog serisi: derleyici! Tam olarak ne derleyicisi olduğunu açıkçası ben de bilmiyorum, baştan düzgün bir derleyici yazmak olacak amacım daha çok. Yine de kafamda bazı nitelikleri mevcut bu dilin. Derleyicinin ilk sürümünü de Rust’ta yazmayı hedefliyorum. Bu sefer lafı dolandırmak istemiyorum pek, o nedenle başlayalım!</p>
<h1 id="dilin-sözdizimi">Dilin Sözdizimi</h1>
<p>Öncelikle sözdizimsel (<em>syntactic</em>) özelliklerinden bahsedelim bu dilin.</p>
<ul>
<li>Genel olarak C benzeri bir sözdizimi olmalı. Örneğin <code>int foo(int x)</code> C’deki gibi fonksiyon başlığı olmalı</li>
<li>C’de bildiğiniz (veya bilmediğiniz) üzere gramer olarak birtakım belirsizlikler (<em>ambiguities</em>) mevcut. En basit örnek <code>(Foo)(x)</code> olur muhtemelen. Kodun öncesinde <code>Foo</code>’nun ne olarak tanımlandığına bağlı olarak bu ifade farklı şekillerde yorumlanmak zorunda. Eğer <code>Foo</code> bir tip ise bir değiştirme (<em>casting</em>) işlemi olarak, eğer <code>Foo</code> bir fonksiyon ise <code>x</code>’in argüman olarak verildiği bir fonksiyon çağrısı olarak yorumlanmalı. Bunu çözmek için <a href="https://github.com/c3lang/c3c">C3</a> dilinin yaklaşımından yararlanıp tipleri her zaman büyük, diğer belirteçleri (<em>identifier</em>) her zaman küçük harfle başlamaya <em>zorlamayı</em> düşündüm. Ayrıca kod tarzı açısından da faydalı olacağını düşünüyorum.</li>
<li>Bunun yanında, C++ gibi <code>&lt;&gt;</code> işaretleri ile bir genel (<em>generic</em>) tip veya fonksiyon oluşturacaksak, burada da belirsizler oluşuyor. Bunun çözümlerinden birisi C++ gibi kod anlam kazanana kadar kodu incelemek fakat bu ayırıcımızı (<em>parser</em>) Arap saçına çevirmeye yol açar. Rust’ın bu konudaki çözümü mümkün olan yerlerde <code>&lt;&gt;</code> kullanırken belirsizlik olan genel fonksiyon çağrılarında <code>::&lt;&gt;</code> sözdizimini kullanmak. Java’nın çözümü ise <code>&lt;&gt;</code> ile fonksiyon çağrılarını fonksiyonun <em>öncesine</em> yerleştirmek. Rust’ın yaklaşımı bence oldukça güzel, sadece ufak bir değişiklik ile bunu <code>.&lt;&gt;</code> yapmak bana daha güzel geldi. Bunun güzelliğini ilerleyen kısımlarda biraz daha iyi anlayabileceğiz.</li>
<li>Tipler katı bir şekilde sonek (<em>postfix</em>) yöntemiyle oluşturulmalı. C’de bildiğiniz üzere “nasıl kullanıyorsan öyle tanımla” konsepti var, fakat bunun sonucu <code>void(*(*f[])())()</code> oluyor. Birçok dil bunu önek (<em>prefix</em>) ile çözüyor, mesela benzeri bir tip Go’da <code>var f []func() func() void</code> gibi bir şey oluyor. Rust gibi diller de çok farklı değil. Fakat ben bu sözdiziminin C tarzı sözdizimine uygun olmadığını düşünüyorum, nitekim C# ve Java gibi dillerde dizge (<em>array</em>) tanımlama gibi tip işlemleri sonek mantığıyla yapılıyor. Ben bunu biraz daha net hâle getirmek istiyorum. Bir tipin sonuna
<ul>
<li><code>&amp;</code> eklenirse değişmez (<em>const</em>) referans</li>
<li><code>&amp;mut</code> eklenirse değişir (<em>mutable</em>) referans</li>
<li><code>[]</code> eklenirse kesit (<em>slice</em>)</li>
<li><code>[n]</code> eklenirse <code>n</code> elemanlı bir dizge</li>
<li><code>?</code> eklenirse seçmeli (<em>optional</em>)</li>
<li><code>!T</code> eklenirse <code>T</code> ile sonuç (<em>result</em>) (burada <code>T</code> bir tip belirteci değilse paranteze alınmak zorunda)</li>
<li><code>(...)</code> eklenirse daha önceki verilen tipi dönen ve <code>...</code> içerisindeki parametre türlerine sahip bir fonksiyon
olmasını istiyorum açıkçası. Kısacası yukarıdaki tip <code>void()()[] f</code> olmalı.</li>
</ul></li>
<li>Klasik operatörler olmalı, farklı olarak <code>xor</code>, <code>lsh</code>, <code>rsh</code> anahtar kelime şeklinde olmalı. XOR’u şapka ile göstermek oldum olası saçma gelmiştir, bit kaydırmaları da genel tip ve fonksiyonlarla çakışabileceğinden dolayı anahtar kelime oluyorlar.</li>
<li>Dile <code>let</code> ve <code>var</code> anahtar kelimelerini sokmamak adına <code>=</code> ile atamayı değişmez, <code>&lt;-</code> ile atamayı değişir atama olarak kullanmayı ve bu ikisinin karıştırılmasının yasak olmasını düşündüm.</li>
<li><code>arena</code> ve <code>thread_scope</code> gibi birkaç fazladan anahtar kelime güzel olur gibi.</li>
<li>Önişlemci (<em>preprocessor</em>) yok, üstprogramlama (<em>metaprogramming</em>) şimdilik düşünmediğim bir kısım. Genel olarak tip sistemi ile sorunu çözmeyi planlıyorum. Önişlemci olmadığı için boşluk karakterleri (<em>whitespace</em>) tokenlerin sonunu belirtmek dışında hiçbir işe yaramamış oluyor.</li>
<li>Sayılarda <code>u32</code>, <code>s64</code> ve <code>f32</code> gibi sonekler olabilmeli.</li>
<li>Metinler (<em>strings</em>) C’deki gibi <code>"</code> arasında olmalı, ama <code>"</code>’ın kendisinin kaçış karakteri (<em>escape character</em>) başına <code>\</code> koymak değil <code>''</code> olmalı. Daha fazla sayıda tek tırnak yan yana koyulduğunda konulan tek tırnak sayısının bir eksiği kadar tek tırnak metne dahil edilmeli. Bunun dışındaki kaçış karakterleri aynı, yani yeni satır hâlâ <code>\n</code>.</li>
<li>Lambda fonksiyonlar <code>-&gt;</code> ile oluşturulabilmeli.</li>
</ul>
<p>Aslında özellikle gramer üzerine daha fazlası yazılır ama bu gönderi için bu kadarı fazla bile. Elimizde hangi tokenlerin olacağını gösteren bir liste olmuş oluyor kabataslak yani. Şimdi gelin önce bunları Rust’ta tanımlayalım:</p>
<h1 id="tasarım">Tasarım</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Eq</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Keyword <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    With<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    Struct<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    Enum<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// C types</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    Uchar<span class="op">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    Ushort<span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    Uint<span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    Ulong<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    Ullong<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    Char<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    Short<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    Int<span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    Long<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    Llong<span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Constant-width integers</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    Int8<span class="op">,</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    Int16<span class="op">,</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    Int32<span class="op">,</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    Int64<span class="op">,</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    Uint8<span class="op">,</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    Uint16<span class="op">,</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    Uint32<span class="op">,</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    Uint64<span class="op">,</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    Float<span class="op">,</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    Double<span class="op">,</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Eq</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Punctuation <span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    LeftParen<span class="op">,</span>    <span class="co">// (</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    RightParen<span class="op">,</span>   <span class="co">// )</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    LeftBracket<span class="op">,</span>  <span class="co">// [</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    RightBracket<span class="op">,</span> <span class="co">// ]</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    LeftBrace<span class="op">,</span>    <span class="co">// {</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    RightBrace<span class="op">,</span>   <span class="co">// }</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    Comma<span class="op">,</span>           <span class="co">// ,</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    Dot<span class="op">,</span>             <span class="co">// .</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    QuestionMark<span class="op">,</span>    <span class="co">// ?</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    ExclamationMark<span class="op">,</span> <span class="co">// !</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    Ampersand<span class="op">,</span>       <span class="co">// &amp;</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    Arrow<span class="op">,</span>           <span class="co">// -&gt;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    Equate<span class="op">,</span> <span class="co">// =</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    Assign<span class="op">,</span> <span class="co">// &lt;-</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Arithmetic operators</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    Plus<span class="op">,</span>     <span class="co">// +</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    Minus<span class="op">,</span>    <span class="co">// -</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    Asterisk<span class="op">,</span> <span class="co">// *</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    Slash<span class="op">,</span>    <span class="co">// /</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    Percent<span class="op">,</span>  <span class="co">// %</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Comparison operators</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    Equals<span class="op">,</span>            <span class="co">// ==</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    NotEquals<span class="op">,</span>         <span class="co">// !=</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    LessThan<span class="op">,</span>          <span class="co">// &lt;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    GreaterThan<span class="op">,</span>       <span class="co">// &gt;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    LessThanEquals<span class="op">,</span>    <span class="co">// &lt;=</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    GreaterThanEquals<span class="op">,</span> <span class="co">// &gt;=</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Logical operators</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    And<span class="op">,</span> <span class="co">// &amp;&amp;</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    Or<span class="op">,</span>  <span class="co">// ||</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Not, // !</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Bitwise operatos</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Band, // &amp;</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    Bor<span class="op">,</span>  <span class="co">// |</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    Bxor<span class="op">,</span> <span class="co">// ^</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    Bnot<span class="op">,</span> <span class="co">// ~</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Lexeme<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    Eof<span class="op">,</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    Integer(<span class="dt">i64</span>)<span class="op">,</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    UnsignedInteger(<span class="dt">u64</span>)<span class="op">,</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    Float(<span class="dt">f64</span>)<span class="op">,</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    <span class="dt">String</span>(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    Identifier(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">,</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>    TypeIdentifier(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">,</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>    Keyword(Keyword)<span class="op">,</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    Punctuation(Punctuation)<span class="op">,</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Burada çok fazla kod var gibi gözüküyor ama aslında hepsi bu bahsettiğim farklı token türlerinin tek tek tanımlanmasından ibaret. String sahip (<em>owned</em>) iken neden belirteçlerin sahipsiz olduğunu sorabilirsiniz, cevabı çok zor değil. Metinler veri olarak kaçışlandıktan sonraki hâlleriyle tutulmalı, dolayısıyla yeni bir metin oluşturmak gerekiyor. Fakat belirteçlerde bu yok, dolayısıyla onlar direkt kaynak koda âtıfta bulunabilir.</p>
<p>Bunların yanında bir tokenin kaynağın neresinde olduğunu göstermek için ufak bir yapı tanımlamak mantıklı olacaktır:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Eq</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Copy</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> SourcePosition <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> line<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> column<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> character<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> SourcePosition <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(line<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> column<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> character<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> SourcePosition <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        SourcePosition <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            line<span class="op">,</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            column<span class="op">,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            character<span class="op">,</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>new</code> fonksiyonu çok önemli değil, sadece pozisyon bilgisi oluştururken -özellikle testlerde- kolaylık olsun diye koydum.</p>
<h1 id="kod">Kod</h1>
<p>Bir token oluşturucu yazmanın, kalıp eşleme (<em>pattern matching</em>) olan bir dilde ne kadar kolay olduğunu bu kodu yazarken öğrendim açık konuşmak gerekirse. Bu bahsettiğimiz özellikler genel olarak tek bir <code>match</code> ifadesinin (<em>expression</em>) farklı kollarına tekabûl ediyor. Fakat öncelikle gelin bu tanımlamaları birleştirelim:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Eq</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> LexError <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    UnknownCharacter(<span class="dt">char</span>)<span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Token<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> result<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>Lexeme<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;,</span> LexError<span class="op">&gt;,</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> from<span class="op">:</span> SourcePosition<span class="op">,</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> to<span class="op">:</span> SourcePosition<span class="op">,</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Okuma işlemi sırasında karşılaşabileceğimiz sorunları <code>LexError</code> içerisine koyarsak bir <code>Token</code> bu şekilde tanımlanabilir. Ufak oluşurucular (<em>constructors</em>) da ekleyebiliriz bu <code>Token</code>e:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Token<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> token(result<span class="op">:</span> Lexeme<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;,</span> position<span class="op">:</span> SourcePosition<span class="op">,</span> next<span class="op">:</span> SourcePosition) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>            result<span class="op">:</span> <span class="cn">Ok</span>(result)<span class="op">,</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            from<span class="op">:</span> position<span class="op">,</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            to<span class="op">:</span> next<span class="op">,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> error(result<span class="op">:</span> LexError<span class="op">,</span> position<span class="op">:</span> SourcePosition<span class="op">,</span> next<span class="op">:</span> SourcePosition) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            result<span class="op">:</span> <span class="cn">Err</span>(result)<span class="op">,</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            from<span class="op">:</span> position<span class="op">,</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            to<span class="op">:</span> next<span class="op">,</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Şimdi gelelim asıl olaya. Bunlar sadece elimizdeki gereksinimleri veri yapılarına dökmek oldu bir bakıma, şimdi sırada bu gereksinimleri gerçekleştirmek var.</p>
<p>Öncelikle formatımız şu şekilde:</p>
<ul>
<li>Genel olarak fonksiyonlar <code>source: &amp;[char]</code> alacak. <code>&amp;str</code> yerine <code>&amp;[char]</code> almamızın sebebi, <code>&amp;str</code> bir kesit olmadığından ötürü kendisinin kalıplarla kullanımının zor olması. Fakat çağıran fonksiyon bize kaynağı bu şekilde verebilir. Ki sonra bahsedeceğim gibi bunu da daha otomatik hâle getireceğiz.</li>
<li>Kesitler hiçbir zaman değişmemeli/dönüşmemeli, pozisyon verisi üzerinden nerede olduğumuz yürümeli. Bunu kolaylaştırmak için şu şekilde bir fonksiyon da yazdım:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> SourcePosition <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> apply<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> [<span class="dt">char</span>]) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> [<span class="dt">char</span>] <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;</span>s[<span class="kw">self</span><span class="op">.</span>character<span class="op">..</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>O zaman öncelikle ilk fonksiyonumuzdan başlayalım: <code>skip_whitespace</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Token<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> skip_whitespace(source<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">char</span>]<span class="op">,</span> position<span class="op">:</span> SourcePosition) <span class="op">-&gt;</span> SourcePosition <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> position <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> position<span class="op">.</span>apply(source) <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> c <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">&amp;</span>c <span class="cf">if</span> c<span class="op">.</span>is_whitespace() <span class="op">=&gt;</span> position <span class="op">=</span> position<span class="op">.</span>next(c)<span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                _ <span class="op">=&gt;</span> <span class="cf">break</span><span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        position</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Aslında oldukça basit bir fonksiyon: boşluk karakteri olduğu sürece karakterler üzerinde dön ve her boşluk karakteri için pozisyonu sonraki pozisyona getir. Başka bir karakter görünce döngüden çıkıp pozisyonu dön. Bu ilk karakter de olabilir son karakter de, ama son karaktere kadar gitse bile ötesine geçmiyor iterasyondan kaynaklı olarak. Dolayısıyla sadece boşluktan oluşan bir metinde pozisyon doğrudan metnin bir sonraki karakteri olacaktır.</p>
<p>Burada asıl büyü bir bakıma <code>next</code>’te oluyor ama aslında o da çok basit bir fonksiyon:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> SourcePosition <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> c<span class="op">:</span> <span class="dt">char</span>) <span class="op">-&gt;</span> SourcePosition <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> c <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>            <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span> <span class="op">=&gt;</span> SourcePosition <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                line<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>line <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                column<span class="op">:</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                character<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>character <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> SourcePosition <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                line<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>line<span class="op">,</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                column<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>column <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                character<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>character <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Açıklaması yine basit: yeni satır olursa sonraki satıra geçerken diğer karakterlerde sütunu ilerletiyor. Karakter konumu ise sürekli olarak devam ediyor karakterin ne olduğundan bağımsız olarak.</p>
<p>Tam olarak şimdi token oluşturucumuzun kalbine geliyoruz:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Token<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> dispatch(source<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;_</span> [<span class="dt">char</span>]<span class="op">,</span> position<span class="op">:</span> SourcePosition) <span class="op">-&gt;</span> Token<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (result<span class="op">,</span> next) <span class="op">=</span> <span class="cf">match</span> position<span class="op">.</span>apply(source) <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>            [] <span class="op">=&gt;</span> (<span class="cn">Ok</span>(<span class="pp">Lexeme::</span>Eof)<span class="op">,</span> position)<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            [c <span class="op">@</span> <span class="ch">&#39;(&#39;</span><span class="op">,</span> <span class="op">..</span>] <span class="op">=&gt;</span> (</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Ok</span>(<span class="pp">Lexeme::</span>Punctuation(<span class="pp">Punctuation::</span>LeftParen))<span class="op">,</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                position<span class="op">.</span>next(<span class="op">*</span>c)<span class="op">,</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            )<span class="op">,</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            [c <span class="op">@</span> <span class="ch">&#39;)&#39;</span><span class="op">,</span> <span class="op">..</span>] <span class="op">=&gt;</span> (</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Ok</span>(<span class="pp">Lexeme::</span>Punctuation(<span class="pp">Punctuation::</span>RightParen))<span class="op">,</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                position<span class="op">.</span>next(<span class="op">*</span>c)<span class="op">,</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            )<span class="op">,</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            [c<span class="op">,</span> <span class="op">..</span>] <span class="op">=&gt;</span> (<span class="cn">Err</span>(<span class="pp">LexError::</span>UnknownCharacter(<span class="op">*</span>c))<span class="op">,</span> position<span class="op">.</span>next(<span class="op">*</span>c))<span class="op">,</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        Token <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            result<span class="op">,</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            from<span class="op">:</span> position<span class="op">,</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            to<span class="op">:</span> next<span class="op">,</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Açıkçası bu kod tam olarak tamamlanmış değil. Fakat güzel yanı, genişletmesi genel olarak oldukça kolay. Asıl sorunlu olan iki durum üstteki boş metin durumu ile en alttaki bilinmeyen karakter durumu. Geri kalanı bizim gerçek tokenlerimizi oluşturacak. Dediğim gibi, kalıp eşlemeli bir dilde bunu yapmak oldukça kolay oluyor. İlk karakter parantez açma ise, geri kalanı umursamayıp sol parantez tokeni döndürüyoruz. Elimizdeki tokenin konumunu bilmesi biraz değişik olabilir sadece. Bize en son gelen konum aslında başlangıç konumumuz oluyor, tokenin kendisini çözen <code>match</code> kolunun bildireceği yeni başlangıç konumu ise tokenimizin yarı açık sonu oluyor. Bu yeni başlangıç konumunu token vermeli çünkü tokenin uzunluğunu tokenin kendisini kıyaslarken ancak öğrenebiliriz. Parantezler tek karakter ama mesela belirteçler tek karakter değil, herhangi bir sayıda karakter olabilir. Kaç tane olduğunu da ancak tokeni öğrendikten sonra bilebiliriz. Dolayısıyla tokeni öğrendikten sonra yeni başlangıç konumunu hesaplamamız gerekiyor.</p>
<p>Bundan sonrası oldukça basit oluyor aslında. <code>parse</code> fonksiyonu şu oluyor:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Token<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> parse(source<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;_</span> [<span class="dt">char</span>]<span class="op">,</span> position<span class="op">:</span> SourcePosition) <span class="op">-&gt;</span> Token<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> position <span class="op">=</span> <span class="dt">Self</span><span class="pp">::</span>skip_whitespace(source<span class="op">,</span> position)<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Self</span><span class="pp">::</span>dispatch(source<span class="op">,</span> position)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Son olarak da bunu bir iteratöre çevirelim. Bunun için bir yardımcı tip oluşturmamız gerekiyor ama:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Lexer<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> source<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> [<span class="dt">char</span>]<span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> next<span class="op">:</span> SourcePosition<span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Lexer<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(source<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">char</span>]) <span class="op">-&gt;</span> Lexer <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        Lexer <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            source<span class="op">,</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            next<span class="op">:</span> <span class="pp">SourcePosition::</span><span class="kw">default</span>()<span class="op">,</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Eof görene kadar devam etmesini istiyorsak (hataları da dönsün) şu şekilde bir iteratör oldukça yeterli olacaktır:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="bu">Iterator</span> <span class="cf">for</span> Lexer<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Item <span class="op">=</span> Token<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> <span class="pp">Token::</span>parse(<span class="kw">self</span><span class="op">.</span>source<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>next)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>next <span class="op">=</span> result<span class="op">.</span>to<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">let</span> Token <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            result<span class="op">:</span> <span class="cn">Ok</span>(<span class="pp">Lexeme::</span>Eof)<span class="op">,</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            from<span class="op">:</span> _<span class="op">,</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            to<span class="op">:</span> _<span class="op">,</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="op">=</span> result</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="cn">None</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(result)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Kullanımı da oldukça basit oluyor nitekim:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> lex <span class="kw">in</span> <span class="pp">Lexer::</span>new(<span class="st">&quot;(&quot;</span><span class="op">.</span>chars()<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>()<span class="op">.</span>as_slice()) <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> lex)<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Kodun yarısı <code>&amp;str</code>’yi <code>&amp;[char]</code>’a çevirmek! Çıktımız da tam olarak beklenecek şekilde:</p>
<pre><code>Token {
    result: Ok(Punctuation(LeftParen)),
    from: SourcePosition { line: 1, column: 1, character: 0 },
    to: SourcePosition { line: 1, column: 2, character: 1 }
}</code></pre>
<h1 id="sonuç">Sonuç</h1>
<p>Bir token oluşturucu yazmak işte bu kadar kolay aslında! Fakat yine de ciddi eksiklikleri var bu kodun. Sayıları, metinleri ve belirteçleri henüz token hâline getirmiyor fakat eklemesi kolay aslında baya. Her birinin ayrı türden bir karakterle başlaması büyük nimet gerçekten.</p>
<p>Bir sonraki gönderide görüşmek üzere!</p>

				<hr/>
		<p>Gönderim Zamanı: 2025-09-30 22:36:06+03:00</p>
		
				<p>Etiketler: Rust, Programlama, Teknoloji, Gönderi, Derleyiciler</p>
		
		<footer>
			<p class="footer-text">© Erencan Ceyhan, 2025</p>
			<div class="footer-text" id="links">
				<a href="https://github.com/erenjanje">GitHub</a>
				<a href="https://www.linkedin.com/in/erencan-ceyhan/">LinkedIn</a>
				<a href="mailto:erencan.ceyhan@hotmail.com">E-Posta</a>
			</div>
		</footer>
		<iframe id="guest-book" src="https://lukantima.atabook.org/"></iframe>
	</article>

	<img src="/consbar.gif"/>
</body>

</html>
